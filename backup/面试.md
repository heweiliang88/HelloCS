# 面试

# 面试复习

- git：
- svn：
- css3：
- html5：
- javascript：
- es6：
- typescript：
- vue：

# 面试题

> 文章
>
> - [ ] [一篇文章搞定前端面试](https://juejin.cn/post/6844903687593148429)
> - [ ] [分享收集的一大波前端面试题和答案](https://juejin.cn/post/6844903569896767501)
> - [ ] [高仿移动端网易云音乐 Vue前端项目](https://juejin.cn/post/6844903825401184270)
> - [ ] [前端模拟面试字数过23477万内容｜刷题打卡](https://juejin.cn/post/6948576107163549732)
> - [ ] [Web前端工程师P5~P6 - 九章算法](https://www.jiuzhang.com/course/75/?utm_source=sc-zhihu-swj0415)
> - [ ] [30 seconds of code](https://www.30secondsofcode.org/)
> - [ ] [Codrops | Creative front-end resources and inspiration for web professionals](https://tympanus.net/codrops/)
> - [ ] [Learn to Code Advanced HTML & CSS](https://learn.shayhowe.com/advanced-html-css/)
> - [ ] [Learn HTML5, CSS3, Javascript - video style tutorials](https://thecodeplayer.com/)
> - [ ] [fyuanfen/fyuanfen.github.io: 前端练手的小项目](https://github.com/fyuanfen/fyuanfen.github.io)
> - [ ] 

> 书籍
>
> - [ ] 前端程序员面试笔试真题库
> - [ ] 前端程序员面试秘籍
> - [ ] 剑指office

# 简历学习

HTML&CSS：
浏览器内核

盒模型、flex布局、两/三栏布局、水平/垂直居中；
BFC、清除浮动；
css3动画、H5新特性。
JavaScript：
继承、原型链、this指向、设计模式、call, apply, bind,；
new实现、防抖节流、let, var, const 区别、暂时性死区、event、loop；
promise使用及实现、promise并行执行和顺序执行；
async/await的优缺点；
闭包、垃圾回收和内存泄漏、数组方法、数组乱序, 数组扁平化、事件委托、事件监听、事件模型
Vue:
vue数据双向绑定原理；
vue computed原理、computed和watch的区别；
vue编译器结构图、生命周期、vue组件通信；
mvvm模式、mvc模式理解；
vue dom diff、vuex、vue-router
网络：

HTTP1, HTTP2, HTTPS、常见的http状态码；
浏览从输入网址到回车发生了什么；
前端安全（CSRF、XSS）
前端跨域、浏览器缓存、cookie, session, token, localstorage, sessionstorage；
TCP连接(三次握手, 四次挥手)
性能相关

图片优化的方式
500 张图片，如何实现预加载优化
懒加载具体实现
减少http请求的方式
webpack如何配置大型项目

前端发展

- 刀耕火种 十多年前的前端 html、css 、js 、jq 
- 工程化   2011 ~ 2014 年 模块化的思路占为主导
	- 模块化协议 AMD（RequireJS）、CMD（Seajs 为代表）、KMD（Kissy 为代表）
- 移动化 3G、4G 的发展和 iOS 和 Android 手机在市场的普及量大增  PC业务 ==> 移动端
- 框架化  Angular、React、Vue、RN （React Native） MV* 框架 前端接受了数据驱动思想 Weex、Flutter  构思前端页面在移动终端上的加载性能和用户体验表现
- 垂直化 随着初代 iPhone 的发布，大屏幕手机逐渐变成了主流，移动端的需求开始爆发
	- 前端的领域也随着这种趋势逐渐细分，按照场景可以简单分为移动(无线)前端开发和中后台前端开发。
		- 移动前端开发面向的是消费者端的 Web 与 轻 App 业务场景
		- 中后台前端则是面向企业 ERP、CRM 、OA 等偏后的业务场景，如商家后台等系统。
			- ERP
			- CRM
			- OA

原本，移动客户端开发和前端开发是两条没有交集的平行线，但是，混合式(Hybird)应用开发，或者用最近比较火的一个概念 -- 大前端技术

从技术的表现形式思考，本质上客户端开发与前端开发都是终端技术，它的特点是直接面向用户 UI 编程。



技术  ==》 结合业务聊技术

前端的追求：界面美观惊艳、页面交互流畅、业务逻辑清晰、组件化合理、对外sdk稳定等。

后端的追求：接口稳定、架构合理、业务逻辑清晰、模块拆分合理、支持高并发等。

前端的追求：界面美观惊艳、页面交互流畅、业务逻辑清晰、组件化合理、对外sdk稳定等。

后端的追求：接口稳定、架构合理、业务逻辑清晰、模块拆分合理、支持高并发等。



事件原理，闭包，调用栈，Promise，ES6， 工程化，webpack, 性能优化，跨域，安全问题， React、Redux 思想，Virtual DOM，Diff 算法， 移动端布局，浏览器渲染原理，Event Loop 等



手写代码，主要考察一些基本 API 和 ES6 的使用。最常见是在 Array、String prototype 上写一个函数。



常用的函数，比如 bind (好多家都考……)，throttle, debounce 





- 面对每次工作和面试中碰到的问题，还是要踏踏实实的去理解和总结。

- 广度深度两手抓，一是主动承担业务，主动解决问题。二是技术栈也不要给自己设限，React, Vue, 客户端开发，Node，Canvas ... 撸起袖子就是干，当然拓展广度的同时，对于目前紧迫的业务涉及的技术也需要深入了解，买书，买视频，多多投资自己。

- 多多思考和总结平常的工作和技术。

	乐于分享，一是督促学习，二是锻炼自己的表达总结能力，三是这些分享的材料都是自己学习能力的证明，四是找到同类，扩大影响力。



面试技巧
确定核心诉求、筛选目标公司
一份确保可以拿到 offer 的简历
打磨自我介绍
打磨项目介绍
面试录音（征得许可后）、面后复盘
私下与业务负责人互动
offer 谈判

【面试技巧】面试中令人不舒服的行为： 1.口头禅过多:嗯，呃，然后… 2.过于放松的坐姿 3.简历格式不统一，页数过多 4.疯狂的输出，自说自话： 例如“我今年大三，明年大四”“也不是稳进吧，就是几率大一点”不如直接说“我今年大三”“如何几率大一点”思考过程就留在大脑里吧，就把思考结果表达出来就好了



万能公式

1.基础信息

2.任职经历

3.个人能力

4.成就贡献

自我介绍



您好，我叫何伟亮，毕业于广东工贸职业技术学院的软件技术专业。主要使用的技术栈前端使用vue和后端使用nodejs，喜欢折腾计算机技术，也对计算机技术充满了好奇。

专注于前端学习和知识分享，搭建过个人博客和个人前端知识手册 前端体系。



我的简历上项目主要有两个，一个是pc端的音乐网站，

另一个也是pc端思维导图，

音乐网站主要使用的技术是vue全家桶，实现了音乐网站的大部分功能，包括音乐的播放暂停，歌词，搜索功能等等

思维导图主要使用的是vue全家桶 和 echarts 实现了思维导图节点的增删改查

我的个人目标是争取在某一天能给开源社区作出自已的贡献。在日常生活中，我也保证着良好的学习习惯。并能很好的更新自己的技术栈。目前正在学习微信小程序和微信公众号开发。



在今后的职业规划中希望朝着前端的深度学习，并以能开源社区创建一个热门的代码库为终身学习目标。









- 注意数据结构的学习 leetcode js 刷题
- vue的学习
- 微信小程序的学习 项目
- uni app的学习 项目 源代码
- 项目开发
- 不要提及
- vue
- 博客
- 项目
- 自我介绍渗
- 微信小程序
- 微信公众号
- 早上学习技术
- 中午看源码
- 晚上敲代码



总结：1.API思想：通过对方需求决定己方输出，所有人都可以被看成是Api，这样可以极大提高工作效率，精准解决问题。

2.权威大牛都是人，框架工具都是人写的，是可以学习、模仿、甚至自制的，以学习者挑战者的心态去面对，而不是自认为无法逾越。





职位类型：全职 所属部门：研发部 职位亮点：团队氛围好,技术提升快,发展前景好 职位描述: 1. 参与公司WEB应用开发，包括PC端及移动端，负责网站由图形设计到具体页面的实现； 2. 配合服务器端开发人员，调整与排版前端页面，具备前后端分离开发经验； 3. 参与技术预研和技术重构，参与团队交流，协助产品开发； 4. 针对前端，进行各浏览器的性能优化，解决各种浏览器的兼容问题； 5. 配合产品设计人员，参与产品交互设计，高质量实现产品UI和交互方面的开发需求，确保产品具有优质的用户体验。 任职要求： 1. 精通HTML5、JavaScript、CSS3等Web开发技术； 2. 熟练掌握Vue前端栈并有相关项目经验，熟练使用jQuery、Bootstrap； 3. 对Web标准有良好认识，能够高保真还原设计稿，代码风格严谨工整； 4. 熟悉浏览器工作模式，了解主流浏览器引擎（WebKit、Gecko、Trident等），能够解决常见浏览器兼容性问题及性能优化问题，熟悉HTTP的基本工作原理及Web常用开发工具； 5. 熟悉设计模式，熟练掌握面向对象编程和事件驱动编程风格，能够独立完成复杂前端模块设计与实现； 6. 有热情，酷爱技术，有良好的计划、协调、沟通能力，较强的逻辑分析能力和应变能力，良好的团队合作精神。 7. 了解Flutter技术，熟悉Dart语言者优先考虑；



省流小助手[OK]

\1. 你的个人信息，入职公司信息等是否准确

\2. 职位名称是否清晰

\3. 试用期多久，试用期薪资待遇

\4. 薪资多少，薪资结构

\5. 入职报到的地址和时间，需要带的材料

\6. offer一般会写清楚要在几月几号之前通过什么方式回复，如果已经有了更好的选择记得要主动沟通。



应届生签网签没问题，但是！！！一定不能买社保，一定不能买社保！！！！（社保一但买了就不是应届生了）！！毕业两年期间都没买社保，那么你就是这也毕业生（那么很多应届生可以参考的岗位各方面你也可以）！！最后最后还要记得，除了买社保外，你的档案一定一定要在你的生源地人才中心！！！！！！不能过你手，也最好别进你随便签的单位（虽然单位大多没有保管档案的条件，如果有的话，派遣档案的话，同学们三思而后行）



职位类型：实习 所属部门：IT部 职位亮点：人性化管理,工作气氛好,快速成长 岗位职责： 1、根据设计图完成页面制作； 2、与后台开发工程师协作，完成操作交互、数据展现； 任职要求： 1、本科及以上学历，计算机或相关专业毕业； 2、熟悉Html5/DIV+CSS3等前端领域新技术，熟悉W3C、ES标准，对前端模块化、Web语义化有一定的理解； 3、掌握Javascript，掌握Jquery、 Vue等主流js框架。 熟练运用Vue，有Nodejs相关经验优先； 4、熟练处理浏览器兼容性问题及调试工具； 5、有参与过团队项目、响应式页面开发经验优先； 6、良好的沟通能力和团队协作能力；较强的学习能力、责任心、主动性和抗压能力。

记忆力

理解力

逻辑能力





[Web 开发技术 | MDN](https://developer.mozilla.org/zh-CN/docs/Web)

- 熟练运用版本控制工具Git和SVN
	-  Git
	- SVN

- 熟练使用HTML+ CSS还原设计稿，熟悉HTML5新属性以及语义化
	- HTML学习
	- CSS学习

- 熟练JavaScript，了解TypeScript，掌握ES6以上常用语法
	-  JS
	- 对象 DOM BOM
	- ES6

- 熟练使用Vue.js框架，能使用脚手架工具、UI库和常用开发技术构建项目
	-  Vue
	- webpack
	- Vue-cli
	- axios

- 掌握前端性能优化，能够解决前端性能问题
	- webpack
- 掌握基本的Linux命令和服务器运维
	- Centos

- 了解Node.js等基本语法，了解Express框架开发项目
	- Node.js
	- Express

- 了解微信小程序、微信公众号，h5开发等项目开发
	- 微信小程序
	- 微信公众号
	- h5开发



- vue全家桶的学习
- es6
- 浏览器兼容性问题
- 适配移动端
- 微信小程序 
- 微信公众号
- 项目

# 面试题目

> - [ ] [MVC，MVP 和 MVVM ](http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html)
>
> - [ ] [2020初级前端面试题](https://juejin.cn/post/6844904176837722120#heading-37)
> - [ ] [面试带你飞：这是一份全面的 计算机网络基础 总结攻略](https://juejin.cn/post/6844903592965439501)

- ajax 的优点和缺点：

Ajax的给开发者带来的好处大家基本上都深有体会，如下：
1、最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。
2、使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。
3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。
4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。
二、ajax的缺点
1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。那么对于这个问题有没有办法？答案是肯定的，用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）
但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。
2、安全问题
技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。
3、对搜索引擎的支持比较弱。
4、破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。
5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，有一个url地址，如果采用了ajax技术，也许在该url地址下面看到的和别人在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。
6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，如手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的。

- js 中 == 和 === 的区别



- vue-loader是什么？使用它的途径有哪些？

一、vue-loader作用：
解析和转换.vue文件。提取出其中的逻辑代码 script,样式代码style,以及HTML 模板template，再分别把他们交给对应的loader去处理
二、用途
js可以写es6,style样式可以写scss或less、template可以加jade等
三、
css-loader：加载由vue-loader提取出的CSS代码
vue-template-compiler：把vue-loader提取出的HTML模板编译成可执行的jacascript代码

- vue `$set`

[vue通信、传值的多种方式（详细）_飞歌Fly的博客-CSDN博客_vue传值](https://blog.csdn.net/qq_35430000/article/details/79291287)

当你把一个普通的 JavaScript 对象传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的属性，并使用 [`Object.defineProperty`](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FdefineProperty) 把这些属性全部转为 [getter/setter](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FGuide%2FWorking_with_Objects%23%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters)。

受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。

- [::before和::after伪元素的用法 - starof - 博客园](https://www.cnblogs.com/starof/p/4459991.html)

	::before和::after下特有的content，用于在css渲染中向元素逻辑上的头部或尾部添加内容。

	这些添加不会出现在DOM中，不会改变文档内容，不可复制，仅仅是在css渲染层加入。

	**单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。**

[::before 和 :after中双冒号和单冒号 有什么区别 - 知乎](https://zhuanlan.zhihu.com/p/54784296)

- v-bind v-if v-else v-for v

- vue-router 
- location.href 

vue-router与location.href的用法区别
①vue-router使用pushState进行路由更新，静态跳转，页面不会重新加载；location.href会触发浏览器，页面重新加载一次

②vue-router使用diff算法，实现按需加载，减少dom操作

③vue-router是路由跳转或同一个页面跳转；location.href是不同页面间跳转；

④vue-router是异步加载this.$nextTick(()=>{获取url})；location.href是同步加载

- vue 传递参数方法

[vue通信、传值的多种方式（详细）_飞歌Fly的博客-CSDN博客_vue传值](https://blog.csdn.net/qq_35430000/article/details/79291287)

- 相同点：v-if与v-show都可以动态控制dom元素显示隐藏

	不同点：v-if显示隐藏是将dom元素整个添加或删除，而v-show隐藏则是为该元素添加css--display:none，dom元素还在。

- 页面字体边清晰，变细

CSS3里面加入了一个`-webkit-font-smoothing`属性。

这个属性可以使页面上的字体抗锯齿,使用后字体看起来会更清晰舒服。

 

它有三个属性值：

none —— 对低像素的文本比较好

subpixel-antialiased——默认值

antialiased ——抗锯齿很好

eg:

body{-webkit-font-smoothing: antialiased;}

这个属性可以使页面上的字体抗锯齿,使用后字体看起来会更清晰。



# 业务题

# Git





# SVN





# HTML && HTML5

### HTML 语义化

- HTML5 语义化标签  header nav aside article main  figcaption figure footer 
- 选择与语义相符合的标签，使代码语义化
- 便于开发者进行阅读，同时也能维护和写出更优雅的代码
- 让搜索引擎和浏览器等工具更换地解析

### Meta Viewport

- Meta 元信息

# CSS && CSS3

[你未必知道的49个CSS知识点](https://juejin.cn/post/6844903902123393032)

布局

- [x] [Flex 布局教程：语法篇 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

Flex 布局以后，子元素的`float`、`clear`和`vertical-align`属性将失效

父元素

```css
flex-flow:flex-direction(方向) flex-wrap(换行);

justify-content:flex-start | flex-end | center | space-between | space-around; // 主轴上的对齐方式
align-items: flex-start | flex-end | center | space-between | space-around | stretch; // 交叉轴的对齐方式

align-content: flex-start | flex-end | center | space-between | space-around | stretch; //  多根轴线的对齐方式
```

子元素

```css
order // 排列顺序。数值越小，排列越靠前 默认为0

flex:flex-grow(放大比例) flex-shrink(缩小比例) flex-basis(分配多余空间);

align-self: auto | flex-start | flex-end | center | baseline | stretch; // 属性允许单个项目有与其他项目不一样的对齐方式
```

- [ ] [CSS Grid 网格布局教程 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)

> 设置父元素的行和列中grid-templated属性row和column可以设置单元格的宽度和高度，就不用设置子元素的宽高

容器属性

```css
// 行row 列column 单元格
// 设置行和列 3 * 3 
grid-template-columns:100px 100px 100px
grid-template-rows:repeart(3,100px)
// repeart() 重复 auto-fill 自动填充 repeart(auto-fill,100px)
// fr 关键字 片段
minmax() // 函数产生一个长度范围
grid-template-columns: 1fr 1fr minmax(100px, 1fr);
// auto 关键字表示由浏览器自己决定长度

// 网格线名称
  grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];
  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];
// 同一根线有多个名字，比如[fifth-line row-5]

// 间距
grid-row-grap
grid-column-grap


// 区域 别名
grid-template-areas

grid-template-columns: 100px 100px 100px;
grid-template-rows: 100px 100px 100px;
grid-template-areas: 'a b c'
'd e f'
'g h i'

grid-template-areas: "header header header"
                     "main main sidebar"
                     "footer footer footer";

grid-template-areas: 'a . c'
                     'd . f'
                     'g . i';

// row column
grid-auto-flow:row(先行后列)
column (先列后行)
row dense  // 表示"先行后列"，并且尽可能紧密填满，尽量不出现空格。
column dense // 表示"先列后行"，并且尽量填满空格。
// 划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是"先行后列"，即先填满第一行，再开始放入第二行，即下图数字的顺序。


// flex justify-content align-items
// grid 
justify-items:start | end | center | stretch; 单元格内容的水平位置（左中右）  
align-items: start | end | center | stretch; 设置单元格内容的垂直位置（上中下） 
place-items:align-items justify-items 合并简写形式

justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
//属性是整个内容区域在容器里面的水平位置（左中右）
align-content: start | end | center | stretch | space-around | space-between | space-evenly; 
// 整个内容区域的垂直位置（上中下）
place-content: <align-content> <justify-content>

grid-auto-columns 属性，
grid-auto-rows 属性
有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。
grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。
下面的例子里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。


grid-template 属性，
grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。

grid 属性
grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。
```

项目属性



```css
grid-column-start 属性，
grid-column-end 属性，
grid-row-start 属性，
grid-row-end 属性

grid-column 属性，
grid-row 属性

grid-area

justify-self 属性，
align-self 属性，
place-self 属性
```



```css
// 两栏布局
grid-template-columns:70%,30%;
// 传统十二网格
grid-template-colums:repeart(12,1fr)
```

### [干货!各种常见布局实现+知名网站实例分析](https://juejin.cn/post/6844903574929932301)

HTMl5 关于语义化的标签（语义元素）

- <header>

- <nav>

- <section>

- <article>

- <aside>

- <figcaption>

- <figure>

- `<footer>`

![HTML5 语义元素](%E9%9D%A2%E8%AF%95.assets/html5-layout.jpg)

布局：元素的位置

分类：

- 单列
	- 一栏
	- 二栏
	- 三栏
	- 四栏

单列布局

- header,content和footer等宽的单列布局
- header与footer等宽,content略窄的单列布局

```css
// 1 header,content和footer等宽的单列布局
header content footer 
// html 
header + content + footer
// css
height:100px
max-width:960px
margin:0px auto

// header与footer等宽,content略窄的单列布局
// header、footer的内容宽度不设置，块级元素充满整个屏幕，但header、content和footer的内容区设置同一个width，并通过margin:auto实现居中。
<div class="header">
    <div class="nav"></div>
</div>
<div class="content"></div>
<div class="footer"></div>

```

两列布局

- float:left and right
- position 
- 浮动+普通元素的margin





两列自适应布局

- **两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式**
	- float(子)+overflow:hidden（子）:主要通过overflow触发BFC,而BFC不会重叠浮动元素。由于设置overflow:hidden并不会触发IE6-浏览器的haslayout属性，所以需要设置zoom:1来兼容IE6-浏览器。
	- flex 布局

```css
.parent {
  overflow: hidden;
  zoom: 1;
}
.left {
  float: left;
  margin-right: 20px;
}
.right {
  overflow: hidden;
  zoom: 1;
}

//html部分同上
.parent {
  display:flex;
}  
.right {
  margin-left:20px; 
  flex:1;
}

//html部分同上
.parent {
  display:grid;
  grid-template-columns:auto 1fr;
  grid-gap:20px
} 
```

三栏布局

两端自适应，中间定宽

**中间列自适应宽度，旁边两侧固定宽度**

- 圣杯布局：**比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是dom结构必须是先写中间列部分，这样实现中间列可以优先加载**。
	- center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行
	- 如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正padding+负margin可解决，下文会介绍)
- 双飞翼布局：**同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题**。

```css
// 圣杯布局
  <article class="container">
    <div class="center"></div>
    <div class="left"></div>
    <div class="right"></div>
  </article>
  .container {
    padding-left: 220px;//为左右栏腾出空间
    padding-right: 220px;
  }
// float 3个 中间width:100% 自适应  margin-left 和 position: relative 移动位置
  .left {
    float: left;
    width: 200px;
    height: 400px;
    background: red;
    margin-left: -100%;
    position: relative;
    left: -220px;
  }
  .center {
    float: left;
    width: 100%;
    height: 500px;
    background: yellow;
  }
  .right {
    float: left;
    width: 200px;
    height: 400px;
    background: blue;
    margin-left: -200px;
    position: relative;
    right: -220px;
  }
三个部分都设定为左浮动，否则左右两边内容上不去，就不可能与中间列同一行。然后设置center的宽度为100%(实现中间列内容自适应)，此时，left和right部分会跳到下一行
通过设置margin-left为负值让left和right部分回到与center部分同一行
通过设置父容器的padding-left和padding-right，让左右两边留出间隙。
通过设置相对定位，让left和right部分移动到两边。


// 双飞翼布局
<article class="container">
<div class="center">
	<div class="inner">双飞翼布局</div>
</div>
<div class="left"></div>
<div class="right"></div>
</article>

    .container {
        min-width: 600px;//确保中间内容可以显示出来，两倍left宽+right宽
    }
    .left {
        float: left;
        width: 200px;
        height: 400px;
        background: red;
        margin-left: -100%;
    }
    .center {
        float: left;
        width: 100%;
        height: 500px;
        background: yellow;
    }
    .center .inner {
        margin: 0 200px; //新增部分
    }
    .right {
        float: left;
        width: 200px;
        height: 400px;
        background: blue;
        margin-left: -200px;
    }
三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行；
通过设置margin-left为负值让left和right部分回到与center部分同一行；
center部分增加一个内层div，并设margin: 0 200px；

多加一层 dom 树节点，增加渲染树生成的计算量。

```



等高布局

等高布局是指子元素在父元素中高度相等的布局方式

利用正padding+负margin

```
.container {
padding-left: 220px;
padding-right: 220px;
overflow: hidden; //把溢出背景切掉
}
.center,
.left,
.right {
padding-bottom: 10000px;
margin-bottom: -10000px;
}
```

利用背景图片



使用边框和定位



粘连布局

### 清除浮动





### BFC及其应用









[前端基础篇之CSS世界](https://juejin.cn/post/6844903894313598989)

- 绘制三角形

```css
 #one {
     height: 0;
     width: 0;
     border-top: 100px solid transparent;
     border-bottom: 100px solid transparent;
     border-left: 100px solid transparent;
     border-right: 100px solid black;
}
```

- 选择器
	- css 权重 和 超越`!important`
		- 内联 > (#) ID >  类、伪类、属性选择 >  标签、伪元素选择器 > 通用选择器（*）、子选择器（>）、相邻选择器（+）、同胞选择器（~）
		- !important > style > # > . > tag 
		- ` background-color: orange !important;`
			- 权重如何都取有`!important`的属性值。但是宽高有例外情况，由于宽高会被`max-width`/`min-width`覆盖，所以`!important`会失效。

- 盒子

	- margin外边距
		- `margin`属性并不会参与盒子宽度的计算，但通过设置`margin`为负值，却能改变元素水平方向的尺寸：
	- border 边框
		- `border-style`属性的值有`none/solid/dashed/dotted/double`
	- padding  内边距
	- content 内容
	- 盒子大小 
		- w3c 盒模型(显示的大小) =  content(width/height) + padding + border 
			- 元素的宽度计算为`content`的宽度。 
				- width = content width
		- ie 盒模型(显示的大小) = width(height)
			- 元素的宽度计算为`border+padding+content`的宽度总和。
				- width = border + padding +content

- 盒模式 box-sizing 规定容器元素的最终尺寸计算方式

	- `box-sizing: content-box|border-box|inherit:`

	- box-sizing
		- content-box 内容盒子 设置 width/height 设置的是content的宽高
			- 实际宽度和高度 = width[内容的宽度 content ] +  (padding + border) * 2
		- border-box 边框盒子 设置 width/height  设置的是实际显示的宽高，content= width - padding 
			- 实际宽度或高度 = width/height 
	- 内容的宽度或高度(content) vs 显示的宽度或高度(width hegiht)
	- content-box（向外膨胀，破坏DOM结构） (w3c标准盒模型)  默认值，设置 border、padding 会增加元素 width与 height 的尺寸，即 border 与 padding 相当于是元素的“殖民地”，元素的“土地”、尺寸会增加，为向外延伸。
		-  属性width,height只包含内容content，不包含border和padding。
		- 实际显示宽度  =  width[内容的宽度 content ] +  (padding + border) * 2
		- 实际显示高度 = height [内容的高度 content] +  (padding + border) * 2
	- border-box （向内缩小）IE模型（IE盒模式、怪异模式）指定盒模型为 IE模型（怪异模式），设置 border、padding 不会影响元素 width 与 height 的尺寸，即 border 与 padding 由元素已设空间转变。即空间还是这个空间，只是将部分空余的地方，转变成了其他空间用法而已，为内部转变。
		- width(实际显示宽度) =  width(的值)
		- height(实际显示高度)  =  height(的值)
	- 换句话说，就是w3c盒 设置的 width 和 height 不是实际的width 和 height ,而是content的width和height 要 加上 padding 和border，ie盒模型 设置盒子的width 和 height 就是 实际的宽度和高度
		- w3c 盒 width/height （content的宽度和高度）
		- ie 盒 width/height (实际显示的宽度和高度)
	- 注意点
		- 设置`box-sizing:border-box` 当 padding 值大于 width/2 时 实际显示的宽度就会被撑开

```
:root {
  box-sizing: border-box;    
}
* {
  box-sizing: inherit;
}
```



- 块级元素和内联元素
	- 块级元素 `display:block`：单独撑满一行的元素
		- div、ul、li、table、p、h1
	- 内联元素`display:inline-block`：行内元素，指只占据它对应标签的边框所包含的空间的元素
		- span、a、em、i、img、td
- 布局
	- table
	- float
	- position
	- flex
		- 项目：
		- 容器：
	- guid
- 布局
- height min-height和max-height
	- height  高度
	- min-height 最小高度（不超过最小高度）
	- max-height 最大高度（不小于最大高度）
	- min-height （最小 不能低于）vs height 谁大取谁
	- max-height（最大 不能小于） vs height   谁小取谁
	- min-height vs max-height 取min-height

```html
min-height height max-height
(min-height height)  
(height max-height) 
height:200px
min-height:300px
// 实际取 min-height 300px
height:200px
max-height:300px
// 实际取  height 200px
```

- line-height vertical-align
	- 

- px em rem 
	- px 像素 
	- em 相对长度 
	- rem 相对单位（root em，根em） 对于需要适配各种移动设备，使用rem
- 显示与隐藏        





# Sass && Less





# JS





callback promise 递归



- 斐波那契数列

[JS写斐波那契数列的几种方法 - 哥哦狗子 - 博客园](https://www.cnblogs.com/superlizhao/p/11603158.html)

```js
// 1、1、2、3、5、8、13、21

function fibonacci(n) {
    if (n == 1 || n == 2) {
        return 1
    };
    return fibonacci(n - 2) + fibonacci(n - 1);
}
fibonacci(30)
```



# JQuery





# Ajax

### 优点

最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。
使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。
可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求。
基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。

![]()

### 缺点

[vue中Axios的封装和API接口的管理](https://juejin.cn/post/6844903652881072141)



# HTTP

### 什么是跨域，以及如何解决跨域？

跨域是相对于同源策略而言的。





HTTP和HTTPS的区别



HTTP状态码



get和post的区别







# ES6







# TypeScript



# Node

- [ ] [「万字整理 」这里有一份Node.js入门指南和实践,请注意查收 ❤️](https://juejin.cn/post/6844904029219192839)
- [ ] [浏览器与Node的事件循环(Event Loop)有何区别?](https://juejin.cn/post/6844903761949753352)



- [ ] [深入理解Node.js 中的进程与线程](https://juejin.cn/post/6844903908385488903)

进程 process是计算机中的程序关于某数据集合中的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是``资源分配的最小单位``。我们启动一个服务、运行一个实例，就是开一个服务进程。

```js
const http = require('http')
const server = http.createServer();

server.listen(300,()={
    console.log('创建一个进程')
})
```

线程

线程是操作系统能够进行``运算调度的最小单位``，首先我们要清楚线程是隶属于进程的，被包含于进程之中。**一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的**。

- 单线程：**单线程就是一个进程只开一个线程**
- 多线程

```js
const http = require('http');
const longComputation = () => {
  let sum = 0;
  for (let i = 0; i < 1e10; i++) {
    sum += i;
  };
  return sum;
};
const server = http.createServer();
server.on('request', (req, res) => {
  if (req.url === '/compute') {
    console.info('计算开始',new Date());
    const sum = longComputation();
    console.info('计算结束',new Date());
    return res.end(`Sum is ${sum}`);
  } else {
    res.end('Ok')
  }
});

server.listen(3000);
//打印结果
//计算开始 2019-07-28T07:08:49.849Z
//计算结束 2019-07-28T07:09:04.522Z
```

nodejs 是javascruot在服务端的运行环境，构建在Chrome的V8 引擎之上。是单线程模式、基于事件驱动、异步非阻塞模式、可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。充分利用操作系统提供的异步 I/O 进行多任务的执行，适合于 I/O 密集型的应用场景，因为异步，程序无需阻塞等待结果返回，而是基于回调通知的机制，原本同步模式等待的时间，则可以用来处理其它任务，

- 事件驱动 结构是一种建立砸软件开发中一种通用模式之上，这种模式被称为发布-订阅或观察者模式，两个参与者：**主题（subject）\**和\**观察者（observer）**。个实体广播一条消息，其他实体侦听该消息。
- 异步非阻塞模式
	- IO 概念
		- 同步（Synchronous）
		- 异步( Asynchronous)
		- 阻塞( Blocking )
		- 非阻塞( Nonblocking)



- [ ] [一个前端渣渣的node开发体验](https://juejin.cn/post/6844904150291972110)
- [ ] [一篇文章构建你的 NodeJS 知识体系](https://juejin.cn/post/6844903767926636558)
- [ ] [8年前端开发的知识点沉淀(不知道会多少字，一直写下去吧...)](https://juejin.cn/post/6844903870276042759)
- [x] [「nodejs + docker + github pages 」 定制自己的 「今日头条」](https://juejin.cn/post/6844904002056912903)

- node-schedule 定时任务
- purppeteer 是 Google Chrome 团队官方的一个工具,提供了一些 API 来控制 chrome!(一听就很刺激。)[[Puppeteer v9.1.1](https://zhaoqize.github.io/puppeteer-api-zh_CN/#/class-Puppeteer)

### Node



### Express



### Next.js



### Koa





## webpack gulp 



## Vue





## Uni-APP





## 开发技术

lodash

ramda

https://www.lodashjs.com/





## 响应式设计和自适应设计







## H5移动端网页







## PC网页

### 网页布局常见规范





## 微信小程序





## 微信公众号







## 微信小游戏









## 浏览器兼容性问题

> [如何机智地回答浏览器兼容性问题](https://juejin.cn/post/6844903633708908557)

熟悉浏览器兼容问题的解决方法，IE7、8、9、Firefox Goolge 360 等

浏览器类型两种

- PC端
- 移动端



## 计算机网络







## 前端安全















算法  

```js
// 斐波那契数列
var fib = function(n) {
    //  0、1、1、2、3、5、8、13、21
    if(n === 0 || n === 1) return n;
    return fib(n-1) + fib(n-2); 
};
```

```js
// 左旋转字符串
// 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

 var reverseLeftWords = function(s, n) {    
    return s.substr(0,n) + s.substr(n)
};
```



# CSS

> 1. [🎉 CSS 基础拾遗 | 整理了数十万字资料，分享给你这些 CSS 干货 - 掘金](https://juejin.im/post/6844904202339090440)
> 2. [你未必知道的49个CSS知识点 - 掘金](https://juejin.im/post/6844903902123393032)
> 3. [灵活运用CSS开发技巧 - 掘金](https://juejin.im/post/6844903926110617613)
> 4. [干货!各种常见布局实现+知名网站实例分析 - 掘金](https://juejin.im/post/6844903574929932301)
> 5. [前端常用插件、工具类库汇总，不要重复造轮子啦！！！ - 掘金](https://juejin.im/post/6844903683411410951)
> 6. [关于移动端适配，你必须要知道的 - 掘金](https://juejin.im/post/6844903845617729549)
> 7. [个人总结（css3新特性） - 掘金](https://juejin.im/post/6844903518520901639)
> 8. [前端基础篇之CSS世界 - 掘金](https://juejin.im/post/6844903894313598989)
> 9. [我写CSS的常用套路 - 掘金](https://juejin.im/post/6844904033405108232)
> 10. [【建议收藏】90%的前端都会踩的坑，你中了吗？ - 掘金](https://juejin.im/post/6844904024278302728)
> 11. [可能是最全的前端动效库汇总 - 掘金](https://juejin.im/post/6844903830098804743)
> 12. [CSS性能优化的8个技巧 - 掘金](https://juejin.im/post/6844903649605320711)
> 13. https://juejin.im/post/6844904176141467655
> 14. https://juejin.im/post/6854573220306255880

> CSS 和 CSS3常见面试题知识点
>
> - 选择器 ：特殊性、继承、级联
> - 块级元素和行内元素
> - 布局基础：元素、盒模型、BFC、IFC、FFC、浮动及应对方法
> - 字体应用：浏览器如何查找与应用字体
> - 方法论：ITCSS、常见命名方案
> - 常见问题：居中方案（垂直、水平、水平且垂直）、多行文本截断
> - 调试技巧：打印、渲染、标尺

## CSS 的引入方法

- style
- 外联(link)
- import
- 内嵌





## VFM 视觉格式化模型

> 

- 盒子
	- 盒模型
	- 盒子类型
	- 盒子定位
- BFC(Block Formatting Context）块级格式化上下文
- IFC (Inline Formattong Context)  行内格式化上下文
- FFC(Flex Formatting Contest)  伸缩格式化上下文
- TFC(Table Formatting Context)  表格格式化上下文
- 浮动：清除浮动 (float)



## BFC 块级格式化内容

[(29条消息)什么是BFC？看这一篇就够了_Leon的博客-CSDN博客_bfc](https://blog.csdn.net/sinat_36422236/article/details/88763187)



## 层叠上下文





## 边距折叠







## CSS 阻塞







- 命令行、Git
- HTML5、
- CSS3、
- BFC、
- 定位、
- 层叠上下文、
- 边距折叠、



[深入理解CSS外边距折叠（Margin Collapse）](https://tech.youzan.com/css-margin-collapse/)

[CSS之外边距折叠 - 默语 - 博客园](https://www.cnblogs.com/syfwhu/p/5367093.html)

- 浮动布局、
- flex布局、
- grid布局、[(29条消息)guid栅格响应式布局_每日一算-CSDN博客_guid布局](https://blog.csdn.net/qq_41828282/article/details/103268972)
- 兼容
- 渲染机制、
- 白屏、
- FOUC、
- 异步加载、
- 重绘与回流、8种数据类型、运算符优先级、箭头函数、声明前置、函数作用域、块级作用域、作用域链、IIFE、递归、递归优化、柯里化、字符串数组方法（ES5/6）、引用类型、深浅拷贝、正则表达式（贪婪、分组、前瞻）



- 同步与异步、任务队列、微任务与宏任务、节流、防抖、原型、class、原型链、Object.create、组合继承、class继承、call/apply/bind、Object.assign、Mixin、Getter/Setter、闭包、模块封装、高阶函数
- DOM操作、DOM事件流（冒泡、捕获、阻止默认、passive、事件代理）、Cookie/Session鉴权机制、



- Http：状态码、缓存、Session、JWT、Auth2机制、XSS、CSRF原理



- XMLHttpRequest2、fetch、Ajax封装、Comet、Websocket、Mock.js、curl、异步、回调、Promise、async/await、同源策略、JSONP、CORS、服务器中转



- CommonJS规范、NPM、Yarn、开发Package、模块化、IIFE、Parcel.js、ES6的原生Module、NPM Scripts与工程化



- Webpack、手写loader与Plugin、Babel、编译原理



- Vue、Vue Router、Vuex、ElementUI/其他



- React、create-react-app、css modules、styled-component、React Hooks、React Router、Redux/Mobx、Antd/其他



- 小程序、云开发
- 网站性能优化、构建优化、TypeScript



手写代码要求

- 封装ajax
- 封装bind
- 封装防抖节流
- 手写Promise
- 手写React Hooks
- 手写Webpack Loader、Plugin
- 手写MVC、MVVM、React、模块加载器



## 系统任务中的项目

1. 实现选项卡、实现手风琴
2. 实现Tabs标签页、Collapse折叠面版
3. 封装Message消息提示组件、Tooltip文字提示组件
4. 封装Dialog组件、Carousel走马灯组件
5. 结合设计模式与动画实现多特效轮播
6. 原生JS实现在线PPT生成平台
7. 手写Promise
8. Node手写Server
9. 手写Promise
10. 开发Node.js 命令行工具
11. 开发Webpack oader与plugin（replace-loader、markdown-loader、webpack-clean-plugin）
12. 手写React
13. 手写React Hooks
14. React 函数组件 、react-router、mobx 、leancloud 实现图床



## 可选项目（5+3）

### 应用类项目

1. vue 实现技术社区
2. vue 实现共享博客平台
3. vue 实现商城
4. vue 实现记账应用
5. react 实现图床网站
6. react 实现记账应用
7. react 实现番茄工作管理应用
8. 原生JS实现移动端华为音乐
9. 原生JS实现在线Slides应用
10. 原生JS实现画板
11. JQuery实现电视FM
12. Node.js 搭建在线便利贴
13. 翻译小程序
14. 云开发实现聊天小程序

### 造轮子项目

1. 手写Vue
2. 手写MVC
3. 手写Express.js
4. 手写Webpack
5. 手写Redux
6. 手写Vue UI组件库
7. 手写React UI组件库
8. 手写DOM库

- 

- ## 系统任务中的项目

- 1. 实现选项卡、实现手风琴
	2. 实现Tabs标签页、Collapse折叠面版
	3. 封装Message消息提示组件、Tooltip文字提示组件
	4. 封装Dialog组件、Carousel走马灯组件
	5. 结合设计模式与动画实现多特效轮播
	6. 原生JS实现在线PPT生成平台
	7. 手写Promise
	8. Node手写Server
	9. 手写Promise
	10. 开发Node.js 命令行工具
	11. 开发Webpack oader与plugin（replace-loader、markdown-loader、webpack-clean-plugin）
	12. 手写React
	13. 手写React Hooks
	14. React 函数组件 、react-router、mobx 、leancloud 实现图床

- 

- ## 可选项目（5+3）

- ### 应用类项目

- 1. vue 实现技术社区
	2. vue 实现共享博客平台
	3. vue 实现商城
	4. vue 实现记账应用
	5. react 实现图床网站
	6. react 实现记账应用
	7. react 实现番茄工作管理应用
	8. 原生JS实现移动端华为音乐
	9. 原生JS实现在线Slides应用
	10. 原生JS实现画板
	11. JQuery实现电视FM
	12. Node.js 搭建在线便利贴
	13. 翻译小程序
	14. 云开发实现聊天小程序

- ### 造轮子项目

- 1. 手写Vue
	2. 手写MVC
	3. 手写Express.js
	4. 手写Webpack
	5. 手写Redux
	6. 手写Vue UI组件库
	7. 手写React UI组件库
	8. 手写DOM库



css兼容性有哪几种处理方案，

css3新属性有哪些

怎么理解margin越界的问题

js的继承方式有哪些

深拷贝怎么实现

js的事件轮训机制有了解吗

说说call,apply,bind

聊聊es6的promise

为什么要用async，await

vue生命周期

vue双向数据绑定原理

vue的异步更新，以及nexttick

vue路由有哪几种方式，是如何实现的,以及注意事项

vuex的使用，及其原理

http与https的区别

从输入URL到页面展示发生了什么

redux的原理

项目中遇到过什么问题

有没有封装过组件，插件

webpack怎么进行打包的

项目中是怎么优化的

xss怎么处理的

React/Vue

Webpack

Babel

Html5

Css3

Typescript

Sass/Less

Git

# HTML





# CSS

网页布局









# JavaScript

[JavaScript 教程 - 网道](https://wangdoc.com/javascript/index.html)

[分类：JavaScript - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/javascript/)





# Vue

















ajax 的优点（异步JavaScript和XML）

- 无刷新更新数据。
- 异步与服务器通信。
- .前端和后端负载平衡。
- 基于标准被广泛支持
- 界面与应用分离。

缺点

- AJAX干掉了Back和History功能，即对浏览器机制的破坏。
- AJAX的安全问题。（SQL注入攻击和基于Credentials的安全漏洞等等。）







单位

[前端用到的那些单位 - 简书](https://www.jianshu.com/p/f9b34885609d)

- px  像素，相对长度单位
- rpx x单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。
	- rem和rpx的换算关系：rem: 规定屏幕宽度为20rem；1rem = (750/20)rpx
- em 相对长度单位。它没有一个固定数值，支持小数点后三位数
- rem CSS3新增的一个相对单位（root em，根em）
- vh、vw、vmax、vmin 视口指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。
- ch
- ex



max-widht miw-



字体变的更清晰CSS 中

-  -webkit-font-smoothing控制的字体渲染只对MacOS的Webkit有效。



移动 H5 端兼容解决方案

[手把手带你把项目改为移动端适配｜技术点评](https://juejin.cn/post/6937559206413205512)

适配方案

- media queries (媒体查询)

	- 布局

		```
		@media only screen and (max-width: 500px) {
		    body {
		        background-color: lightblue;
		    }
		}
		```

- rem（font size of the root element）对于根元素的字体大小的单位。简单的说它就是一个相对单位，rem 计算的规则是依赖根元素。原理是先按定高宽设计出来页面，然后转换为 rem 单位，配合 js 查询屏幕大小来改变 html 的 font-size

- flex 或者百分比布局 Flex

- viewport 指的是移动设备浏览器中放置页面的一个虚拟的窗口，该窗口可大于或小于移动设备的可视区域。

	- width=device-width ：表示宽度是设备屏幕的宽度
		initial-scale=1：表示初始的缩放比例
		minimum-scale=1：表示最小的缩放比例
		maximum-scale=1：表示最大的缩放比例
		user-scalable=no：表示用户是否可以调整缩放比例

- viewport 

- 布局 用 flex 单位 rem

- 页面存在写死的宽度 ==> 改成百分比

- 页面多处使用绝对定位 和 浮动





H5项目可用的框架

- bootstrap

- MUI SUI

- vuex

- weex

- Mint UI

	





微信小程序生命周期

- 5 应用生命周期
	- onLaunch(初始化)、onshow(启动或切前台)、onHide(切后台)、onError(错误监听)、onPageNotFound(不存在监听函数)
- 12 页面生命周期
	- data(初始化数据)、onLoad(页面加载)、onShow(页面显示)、onReady(初次渲染)、onHide(页面隐藏)、onUnload(页面卸载)
	- onPullDownRefresh(上拉动作)、onReachBottom(上拉触底事件)、onShareAppMessage(右上角转发)、onPageScroll(滚动触发事件的处理函数)、onResize(页面存储触发、响应显示区域变化)、onTabitemTap(tab页)





vue 的UI 库

PC

[2020年 16 个最有用的 Vue UI库 - SegmentFault 思否](https://segmentfault.com/a/1190000021876315)

- element-ui
- ootstrap Vue
- Mint UI
- Vuetify
- Quasar Framework

H5 





微信小程序的框架(多端小程序)

- 原生 weui
- Taro  react 
- wepy
- uni-app vue
- mpvue vue
- wepy
- omi



vue 生命周期

1、beforeCreate（创建前）

2、created（创建后）

3、beforeMount（载入前）

4、mounted（载入后）

5、beforeUpdate（更新前）

6、updated（更新后）

7、beforeDestroy（销毁前）

8、destroyed（销毁后）



后三个不常用

activated

deactivated

errorCaptured





[一年前端面试指南（万字详细答案） - 掘金](https://juejin.im/post/6865600010570989582#heading-0)
[前端进阶必经之路（一）：1.2w字深入理解JavaScript26个核心概念 - 掘金](https://juejin.im/post/6865184344990810126#heading-57)
[由浅入深，66条JavaScript面试知识点 - 掘金](https://juejin.im/post/6844904200917221389)

## JS 运行环境

- Node
- 浏览器
	浏览器内核分为两种：渲染引擎 和 js 引擎
- 渲染引擎：负责网页内容呈现的
- JS引擎：解析js脚本，实现JS交互效果

## 设计模式

## 原型及原型对象

## 作用域与作用域链

<details>   <summary>Click Here to get the user details</summary>   <table>     <tr>       <th>#</th>       <th>Name</th>       <th>Location</th>       <th>Job</th>     </tr>     <tr>       <td>1</td>       <td>Adam</td>       <td>Huston</td>       <td>UI/UX</td>     </tr>   </table> </details>
<h2> Shoppping List(Content Editable) </h2> <ul class="content-editable" contenteditable="true">     <li> 1. Milk </li>     <li> 2. Bread </li>     <li> 3. Honey </li> </ul>

## 闭包

## ES6 Class 语法

## JS  继承

通过继承我们可以使子类具有父类的各种方法和属性，避免了代码的重复输出

## JS 原型链、构造器、原型

## 异步编程

## 内存泄露，优化方法

## 防抖 节流

## 跨域

## 高阶函数和柯里化

柯里化
定义：是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术

## promise

## ES6模块化

## 深拷贝和浅拷贝





## 函数防抖和节流

[防抖、节流 | Shawnchen / XMU 。](http://alloween.top/2018/04/16/%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81/)

### 防抖（debounce）

作用是在``短时间``多次触发`同一个函数`，只执行最后一次，或者只在开始执行

### 节流（throttle）

类似于防抖，  节流是在一段时间内只允许函数执行一次

## 时间戳

时间戳是使用[数字签名](https://baike.baidu.com/item/数字签名/212550)技术产生的数据，签名的对象包括了原始文件信息、签名参数、签名时间等信息。时间戳系统用来产生和管理时间戳，对签名对象进行数字签名产生时间戳，以证明原始文件在签名时间之前已经存在。
[Unix时间戳(Unix timestamp)转换工具 - 站长工具](https://tool.chinaz.com/tools/unixtime.aspx)
Unix 时间戳  可以转变成指定的 时间 

```
Unix 时间 1997128290
2033/4/15 5:51:30
```

获取现在的Unix时间戳(Unix timestamp)

```JavaScript
Math.round(new Date().getTime()/1000)
getTime()返回数值的单位是毫秒
```

实现Unix时间戳(*Unix timestamp*) → 普通时间

```javascript
先 var unixTimestamp = new Date(Unix timestamp * 1000) 然后 commonTime = unixTimestamp.toLocaleString()
```

实现普通时间 → Unix时间戳(*Unix timestamp*)

```javascript
var commonTime = new Date(Date.UTC(year, month - 1, day, hour, minute, second))
var commonTime = new Date(Date.UTC(2090, 1, 23, 3, 34, 23))
Thu Feb 23 2090 11:34:23 GMT+0800 (中国标准时间)
```

## AJAX发送数据请求

## 前端跨域问题

[前端跨域问题 | Shawnchen / XMU 。](http://alloween.top/2017/06/19/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/)

### vue 有多少个生命周期？

vue 有十一个生命周期

常用生命周期：

- beforeCreate
- created
- beforeMount
- mounted
- beforeUpadate
- upadate
- beforeDestory 
- destory 

不常用生命周期

- activated
- deactivated
- errorCaptured

### 微信小程序生命周期

- 5个应用生命周期：onLaunch(初始化)、onShow、onHide(显示隐藏)、onError(错误监听)、onPagNotFound(页面不存在)
- 12个页面生命周期：
	- data(初始数据)、onLoad(加载)、onShow、onHide(显示隐藏)、onReady (渲染完成) 、onUnload(页面卸载)
	- onPullDownRefresh(上拉动作)、onReachBottom(上拉触底事件)、onShareAppMessage(右上角转发)、onPageScroll(滚动触发事件的处理函数)、onResize(页面存储触发、响应显示区域变化)、onTabitemTap(tab页)

### 面试一

ajax的优点和缺点?

> [AJAX工作原理及其优缺点 - SanMaoSpace - 博客园](https://www.cnblogs.com/sanmaospace/archive/2013/06/15/3137180.html)

- ajax 是什么
	- AJAX (Asynchronous JavaScript and XML) 异步的Javascript和XML，是一种创建交互式网页应用的网页开发技术。
- 类似ajax的库
	- axios
	- fetch
	- jquery
	- request
- 优点
	- 无刷新更新数据
	- 异步与服务器通信
	- 前端和后端``负载均衡``
	- 基于标准被``广泛支持``
	- 界面与应用分离
	- 支持异步处理
- 缺点
	- 干掉了Back和History功能，即对``浏览器机制的破坏 Back History ``
	- 浏览器不兼容
	- 不安全 问题 SQL注入攻击
	- 对搜索引擎支持较弱
	- 破坏程序的异常处理机制
	- 违背URL和资源定位的初衷
	- 不能很好支持移动设备
	- 客户端过肥，太多客户端代码造成开发上的成本
	- 增加Web服务器的负载
- 使用场景
	- 表单驱动的交互
	- 深层次的树的导航
	- 快速的用户与用户间的交流响应
	- 类似投票、yes/no等无关痛痒的场景
	- 对数据进行过滤和操纵相关数据的场景
	- 普通的文本输入提示和自动完成的场景
- 不适用场景
	- 部分简单的表单
	- 搜索
	- 基本的导航
	- 替换大量的文本
	- 对呈现的操纵

```html
<div id="myDiv"><h2>使用 AJAX 修改该文本内容</h2></div>
<button type="button" onclick="loadXMLDoc()">修改内容</button>
```

```js
// new XMLHttpRequest  ==> onreadystatechange  xmlhttp.readyState==4 && xmlhttp.status==200  ==> xmlhttp.open() ==> xmlhttp.send()
function loadXMLDoc()
{
    // XMLHttpRequest ActiveXObject("Microsoft.XMLHTTP")
	var xmlhttp;
	if (window.XMLHttpRequest)
	{
		//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
		xmlhttp=new XMLHttpRequest();
	}
	else
	{
		// IE6, IE5 浏览器执行代码
		xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}
	xmlhttp.onreadystatechange=function()
	{
		if (xmlhttp.readyState==4 && xmlhttp.status==200)
		{
			document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
		}
	}
	xmlhttp.open("GET","/try/ajax/ajax_info.txt",true);
	xmlhttp.send();
}
```

js 和 == 和 === 的区别是什么

> [js 中 == 和 === 的区别](https://juejin.cn/post/6844903456407289869)

- "``==``"叫做相等运算符，"``===``"叫做严格运算符
- `===` 严格相等，会比较两个值的类型和值
- `==`  抽象相等，比较时，会先进行类型转换，然后再比较值
- 尽量使用严格运算符 ===。因为"=="不严谨，可能会带来一些违反直觉的后果

v-if 和 v-show 的区别 是什么

- v-if  
	- 
- v-show
	- 

v-loader是什么？有什么作用？

> [vue-loader是什么？使用它的用途有哪些 ](https://www.cnblogs.com/dream111/p/13498766.html)

- 是什么：vue-loader会解析文件，提取出每个语言块，如果有必要会通过其他loader处理，最后将他们组装成一个commonjs模块；module.exports出一个vue.js组件对象
- 作用： vue文件   template  script style `.vue结尾的组件` ==> html文件 
	- template **语言块**  html
		- 最多包含一个< template>块
	- scirpt js
		- 最多包含一个< script>块 
	- style css
		- scoped
		- 可以包含多个< style>标签
	- 自定块
		- 在.vue文件中添加额外的自定义块来实现项目的特殊需求 < docs>块

Vuex中`$set`在什么时候使用



vue传递参数的2种方式



vue-router 跳转和 location.href跳转的区别



4种



:before、:after 



让页面的字体变清晰，变细，用CSS怎么做？



### 面试二(网上面试)



你了解的vue 组件库



H5



HBuilder的使用



微信小程序框架



移动端兼容方案？



### 面试三

vue 生命周期有几个？分别



keep-alive



什么是跨域？怎么解决跨域





你刷新页面表单保存状态





var 、let 和 const的区别

 



### 面试五

ES6 promise的用途、用法



ES6  async





ES6 各个新增函数





vue 父子组件之间通讯（组件之间通信）

父传子

1. props

```

```

子传父

- `emit`

子子

- 

vuex  组件间通信





vue 的生命周期函数

- beforeCreate created
- beforeMount mounted
- beforeUpdate updated
- beforeDestory destory



vuex 是什么? 怎么使用? 那种功能场景使用它？



vue-show和v-if指令的共同点和不同点？



vue路由`$router` 和``$router`的区别？



微信小程序从创建到开发到线上的整理流程？



微信小程序有哪些生命周期，它们具体作用？



let arr = [ {id,}]



vuex 



vue-router





common.js ant.js





面试题



html

Doctype作用，HTML5 为什么只需要写`` <!DOCTYPE HTML>``

- Doctype 是 

行内元素有哪些，块级元素有哪些，空(void)元素有那些

- 行内元素
- 块级元素
- 空元素

HTML语义化的理解



浏览器内核有哪些，介绍一下你对浏览器内核的理解





html5有哪些新特性





 cookie，sessionStorage 和 localStorage 的区别





浏览器内多个标签页之间的通信





HTML5的离线存储怎么使用，解释一下工作原理









css



js



ajax

[vue常见面试题 - 随笔分类(第3页) - 大牛半路出家 - 博客园](https://www.cnblogs.com/dream111/category/1827604.html?page=3)

[vue视频教学 · 前端面试题精编（微信小程序（基础到高级）js视频资源、vue/js/html/css/React/ES6面试题、算法、插件大全）（轻松面对面试）（持续更新） · 看云](https://www.kancloud.cn/lemon-m/js-html-css/998118)

vue

vue



说出几种vue当中的指令和它的用法？

- v-html 渲染为html元素
- v-text 渲染 
- v-if  根据表达式的值的真假条件渲染元素
- v-show 根据表达式之真假值，切换元素的display CSS 属性
- v-for 循环指令，基于一个数组或者对象渲染一个列表
- v-bind:class 动态地绑定一个或多个特性，或一个组件prop 到表达式
- v-on 用于监听指定元素的事件
- v-once 渲染一次
- v-model 数据双向绑定

vue-router



vuex

vuex有几种属性

- state 、getter、mutation、action、module
	- state ==> 数据存储、数据源、基本数据
	- getter ==> 











mvvm mvc mvp mvvm





## 防抖节流

防抖:防止用户手抖多次进行操作

- 触发事件
- setTimeout
- clearTimeout

使用场景

- 改变页面大小的统计
- 滚动页面位置的统计
- 输入框连续输入的请求次数控制

```js
// 防止点击按钮多次提交
<button>按钮</button>
<button>按钮1</button>

var btn = document.getElementsByTagName('button')[0]
var btn1 = document.getElementsByTagName('button')[1]

fucntio payMoney(){
    console.log('已经付款')
}

// 防抖
funciton debounce(func,delay){  // 方法作为参数
 	let timer;
    return function(){ // 高阶函数 函数里面返回函数
        let content = this // this 的情况
        let args = argments
        clearTimeout(timer);
        timer = setTimeout(function(){
           func.apply(content,arguments);
        },delay)
    }
}

btn.addEventListener('click',debounce(payMoney,1000))
btn1.addEventListener('click',debounce(payMoney,1000))
```

- 



节流

滚动屏幕 

- 需要统计用户滚动屏幕的行为来做出相应的网页反应
- 不断请求 ==》 响应不断增加 ==》导致网络阻塞



## CSS 三角形

```css
width:0;
height:0;
border:125px solid black 125px solid black 125px solid black 0 solid black;
margin: 0 auto;
```



## 图片懒加载

> [前端性能优化——图片篇](https://juejin.cn/post/6965761736083243044)

图片懒加载和预加载

```html
<img data-src="photo.png">
<img data-src="photo1.png">
<img data-src="photo2.png">
```

```js
const images = document.querySelectorAll('img');

const callback = entries =>{
      //console.log(entries) // entries 数组
      //console.log('runing!!!')
     //entries.forEarch(entry =>{
       //  console.log(entry); // 是否交叉 可视区域 
     //})
    if(entry.isIntersecting){
        const imgage = entry.target;
        const data_src = image.getAttribute('data-src')
        imge.setAttribute('src',data_src)
        observe.unobserve(image)
        console.log('触发事件！！！')
    }
}

const observe = new IntersectionObserver(callback); //callback 看见了触发 看不见了不触发
// observe.observe(DO节点)
// observe.unobserve(DOM节点)

imges.forEarch(images =>{
     observer.observe(image);
})
```

##  宏任务和微任务

- javascript 是单线程的。也就是只用一个调用栈。调用栈按照先入后出的规则进行的，一次调用一个可以嵌套。在执行调用栈的时候会先执行同步的任务。调用栈在发生异步任务的时候会放进队列里面。异步任务队列分为宏任务队列（硬菜）和微任务队列（软菜）。队列是按照先入先出的规则。

- 宏任务队列，新程序或子程序被直接执行 ，`script`元素里面的代码  事件的回调函数 setTimeout() 和 setInterval() 函数、requestAnimationFrme I/O 操作 setImmediate UI rendering等等

- 微任务队列，Promise() then() catch() finally() 、MutationObserver 、Object.observe、process.nextTick()
- 运行，Event Loop 事件循环 事件循环是一个不断进行的循环的机制。事件循环会不断去寻找可执行的任务来执行
- 先执行调用栈 清空 ==> 微任务队列 清空`promise` ==> 宏任务队列 `setTimeout`
- 调用栈  队列（宏任务队列 和 微任务队列 ）

```js
// 1、script标签（宏任务） 分派是 宏任务队列 和 微任务队列 清空调用栈
// 2、先微任务（优先）（清空）==> 渲染 ==》  宏任务（如果还有微任务重新开始） 【事件循环】

console.log('1');

setTime(function(){
    console.log('2');
},0)

Promise.resolve().then(()=>{
  console.log('3')  
})

setTime(function(){
    console.log('5');
},0)

console.log('4')

// 1 4 3 2 5
```

## 深浅拷贝





## Promise

Promise 两种结果 基本形式 异步处理防止阻塞 

- 如果没有Promise 只有单纯的回调，多个回调重叠在一起就会产生回调地狱的现象

- 成功 resolve() ==》 then  表示成功
	- finally  最终
- 失败 reject()  ==> catch 捕获失败      

```js
const isPregnant = false;

const promise = new Promise((resolve,reject){
	if(isPregnant){
    	resolve('成功')
	}else{
        reject('失败')
    }                            
})

promise.then(name =>{
    		console.log(nane)
		})
       .catch(name =>{
    		console.log(name)
		})
	   .finally(()=>{
       		console.log('最终成功了')
		})
```

```js
const imgAddress = 'https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png'

const imgPromise = (url) => {
    return new Promise((resolve,reject)=>{
        const img = new Image();
        img.src = url;
        img.onload = () =>{
            resolve(img)  
        };
        img.onload = ()=> {
            reject(new Error('图片错误'));
        };
    })
};

imgPromise(imgAddress)
	.then(img =>{
    	document.body.appendChild(img)	
	}).catch(err =>{
    	document.body.innerHTM = err	
	})
```

```js
const promise = new Promise();

// resolve().then()
promise.resolve(()=>{
    
}).then(()=>{
    
}).finally(() =>{
    
})

// reject().catch()
promise.reject(()=>{
    
}).then(()=>{
    
}).finally(() =>{
    
})
```

## 函数柯里化

- 解决重复参数 使用柯里化技术可以很好的复用

```js
function uri(protocol,hostname,pathname){
    return `${protocol} ${hostname} ${pathnane}`
}

const uri1 = url('https://','www.danlaoshi.com'.'/dir');
console.log( uri1)

function url_curring(protocol){
    return function(hostname,pathname)
          return `${protocol} ${hostname} ${pathnane}`
    }
}

const uri_https = url_curring('https://');
const uri2 = uri_https('www.baidu.com','/hello')
const uri3 = uri_https('www.baidu.com','/hello2')
const uri4 = uri_https('www.baidu.com','/hello3')

console.log(url2,url3,url4)
```



```js
funciton add(){
  let args = Array .prototype.slice.call(arguments);
  let inner = function(){
  	args.push(...arguments);
  	return inner;
  }
  inner.toString = function(){
 	return args.reduce(function(pre,cur){
        return prev + cur
    })	 
  }
    return inner;
}

const result = add(1)(2)(3)(4)
console.log(result)
```





## 创建对象的多种方法

- 以名值对的方式存储的
- Object 是所有对象的基类

```js
// 创建方法一
let obj = new Object(); // 创建实例
obj.eat = ['1','2','3']; // 逐个添加属性和方法
obj.effect = function(){
    console.log()
}

// 对象字面量
let obj= {
    eat:['1','2','3'],
    effect:function(){
  
	}    
}

// 工厂模式 对象没法标识
function person(name,age){
    let obj = new Object();
    obj.name = name 
    obj.age = age
    obj.func = funciton(){
        console.log(this.name)
    }
    reutnr obj 
}
let  p1 = Person('hwl',20);
let p2 = Person('nh',30)

p1.func()
问题
console.log(p1 instanceof Person) //false 没有关联

// 构造函数模式
function Person(name,age){ // 大写
    this.name = name  // this指向 
    this.age = age
    this.func = funciton(){
        console.log(this.name)
    } 
}
let  p1 = new Person('hwl',20); // new 隐式的创建对象 并且返回对象
let p2 = new Person('nh',30)

p1.func()
console.log(p1 instanceof Person) 


let mlr2 = Object.create(mlt)
mlt.vegetable.push('内容') 


class MLT(){
    constructor(a,b,c){
        this.a = a 
        this.b = b 
        this.c = c
    }
}
```



## 原型到原型链





## 执行上下文栈





## 变量对象



## 作用域链



## 执行上下文





## 闭包



## call 和 apply 和 apply 





## 箭头函数

- 函数表达式 匿名的
- 普通函数 函数表达式 函数声明 

```
function(){}

()=>{} 
一个参数 不用（） 一个表达式 不用 {}
```



## 继承



## 类class

# 面试题

## HTML 浮动坍塌

```css
div.wrapper{
	overflow:hidden;
}
div.box{
	float:left;
}
div.box1{
	float:right;
}
```

## JavaScript 原型链的使用

- prototype

```js
function People(name){
	this.name = name
}

People.prototype.sayHI = funciton(){
    console.log(this.name)
}

var jerry = new People('Jerry');
jerry.sayHI();
var lucy = new People('Lucy')
lucy.sayHI();
```

## 类型转换等知识

```js
var arr = [
	{
		name: "Jerry",
	},
	{
		name: "Lily",
	},
	{
		name: "Lucy",
	},
	{
		name: "Tomy",
	},
]
// 方案一
var arr2 = 
    
    
// 方案二
    
    
// 方案三
    
// 方案四
    
    
// 方案五
    
    
arr === arr2
arr[0] === arr[0]
arr[1] === arr[1]
arr[2] === arr[2]
arr[3] === arr[3]
```

## 行内元素垂直居中

```html
<p>Jerry is my Lover</p>

p{
	height:30px;
	border:1px solid #ccc;
	line-height:30px;
}
```

js 基础 call 和 apply 的区别 bind

- apply(``函数上下文的对象``,函数参数所组成的``数组``)

- call(函数上下文的对象,后面传入``参数列表``，而不是单个数组)

- apply 和 call 的用法

	- 改变this的指向

	```js
	var obj = {
	    name: 'King'
	}
	function func(){
	    // 把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象
	    console.log(this.name);
	    // 相当于 console.log(obj.name)
	}
	func.call(obj)
	func.apply(obj)
	```

	- 借用别的对象的方法

	```js
	var Person1 = function(){
	    this.name = 'linxin';
	}
	
	var Person2 = function(){
	    this.getname = function(){
	        console.log(this.name)
	    }
	    Person1.call(this); // Person1.name = linxin
	}
	
	var person = new Person2();
	person.getname(); // linxin
	```

	- 调用函数：会使函数立即执行，因此它们也可以用来调用函数。

	```js
	function func(){
	    console.log('linxin');
	}
	func.call();  // linxin
	```

- call 和 bind 的区别

	- bind 发返回值是函数 bind(一个参数是函数上下文的对象,列表（可以接受多个参数）) ES5

	```js
	var obj = {
	    name: 'King'
	}
	
	function func(){
	    console.log(this.name)
	}
	
	func.apply(obj)
	var func1 = func.bind(obj);
	func1();
	```

	bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。

	- 参数的使用

	```js
	function func(a,b,c){
		console.log(a,b,c);
	}
	var func1 = func.bind(null,'linxin');
	func('A','B','C');
	func1('A', 'B', 'C');           // linxin A B
	func1('B', 'C');                // linxin B C
	func.call(null, 'linxin');      // linxin undefined undefined
	```

- ES6里面的call还能用解构来传参

```js
const f = function(a,b,c){
	console.log(a,b,c)
}
const arr = [1,2,3]
f.call(null,...arr)
```

- 求一个数组的最大值，使用 Math.max 函数，但是这个函数入参不支持数组，只能是将多个参数逐个传入，用逗号分隔。

```js
let max = Math.max(1, 4, 8, 9, 0)//es5
let max = Math.max(...[1, 4, 8, 9, 0])//es6
//使用apply
let arr = [1, 4, 8, 9, 0];
let max = Math.max.apply(null, arr);
```

```js
var obj = { 	// 函数上下文的对象
 	name: 'King';
}

function func(firstName,lastName){
	console.log(firstName + '' + this.name + ' ' + lastName);
}

func.apply(obj,['A','B']); // A King B
```

```js
var obj = {
	name: 'King';
}

functino func(firstName,lastName){
	console.log(firstName +‘’ + this.name + '' + lastName);
}

func.call(obj,'C,'D'); // C King D
```



```js
var name = 'jerry';
function sayHi() {
    return 'Hi,I am ' + this.name;
}

// 对象
var lucy = {
    name: 'Lucy',
    sayHi: sayHi,
    sayAnotherHi: function () {
        return sayHi()
    }
};

var tomy = {
    name: 'Tony'
};

console.log(sayHi()) //  Hi,I am jerry
console.log(lucy.sayHi()) // Hi,I am Lucy
console.log(lucy.sayHi.apply(tomy)) // Hi,I am Tony
```

HTML中都有哪些WebAPI

[WindrunnerMax/EveryDay: 前端基础 个人博客 学习笔记](https://github.com/WindrunnerMax/EveryDay)

什么是polyfills? Transpilers?



Babel的作用是什么？



CSSPre-processor有什么作用



Sass 和 Less的区别



Event bubbing?



IIFEs是什么？





call和apply和bind



Destructing是什么？

- 赋值语法糖 destructing & spread 可以通过析构表达式的右边值来同时对左边的多个值进行赋值



# codepen



> [入门指南 – Pug 模板引擎中文文档 | Pug 中文网](https://www.pugjs.cn/api/getting-started.html)
>
> [:after/::after和:before/::before的区别_前端向朔-CSDN博客](https://blog.csdn.net/u013778905/article/details/52901880/)

```
:root {
  --d: 700ms;
  --e: cubic-bezier(0.19, 1, 0.22, 1);
  --font-sans: 'Rubik', sans-serif;
  --font-serif: 'Cardo', serif;
}
```





```
 <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
 
<script src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/16327/gsap-latest-beta.min.js"></script>
        <script src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/16327/CSSRulePlugin3.min.js"></script>
```



伪类 伪元素

before 和 after

:before 

:after

::before 和 ::after

```

```



SCSS

```
$colorRed：#000;
$black: orage; 

@mixin color_render($DC, $LC) {
    background-color: $DC;
    .illustration .inner {
        background-color: $LC;
        &::after, &::before{ background-color: rgba($LC, .4);}
    }
    button {background-color: $LC;}
}
```



必备知识点

- 原型链
- 继承的实现
- 数据类型
- var、const、let 对比
- new 的过程
- this 指向问题
- bind 实现方式
- 闭包
- 事件循环
- 类型判断
- 手写 Promise







- vue 生命周期，每个生命周期项目中什么时候会用
- vue keep-alive 常用属性
- 组件通信方式
- hash 和 history 区别
- v-for 唯一 key
- vue 运行机制，依赖收集
- v-show 和 v-if
- watch 和 computed
- vuex 中模块拆怎么做的





- 数组去重
- css 水平垂直居中





- 一个页面有父子组件，进入之后的渲染顺序触发的生命周期是什么样的
- `keep-alive`，如果只想要`router-view`里面的某个组件被缓存，怎么做
- 组件通信中的`eventbus`原理是什么
- `vue diff`简单讲讲
- 3.0proxy 讲讲，和 2.0 区别（广度）
- `data`为什么是函数
- 常用`vue api`原理(包括不限于`nextTick`,`watch`，`computed`)
- `call`，`apply`，`bind`
- 节流，防抖
- `class`实现





- promise.all 异常处理
- 版本号比较排序
- 数组中第 k 个最大元素
- 二叉树中的所有路径
- 二叉树中和为某一值的路径
- node 中 promisify 实现
- fetch 兼容超时重传
- 观察者模式（高频）
- String indexOf 实现
- 扁平化
- 科里化

- `vue`如何实现组件封装
- 一个动态拖拽的场景，抓取一个`div`之后如何显示最靠近的`div`的基线，就是一条虚线，我这里用队列的方式解决
- 图片，视频断点续传的一些问题
- 因为我`github`有手写`webpack`，针对我写的`webpack`问了几个问题，关于`hook`和生命周期的





[写给初中级前端的高级进阶指南。 - 知乎](https://zhuanlan.zhihu.com/p/117490792)

### **node**

如果简历上写了`koa`，`express`，为什么要使用`koa`(`express`)，直接用`node`不能写吗？中间件本质是什么？类似一些进程相关：孤儿进程和僵尸进程，多线程。因为我用的`php`，所以`node`问题问的比较少，基本面试两个月过来前端面试官都没用过`php` :(

### **项目**

项目中遇到最困难的事是什么（必问），这道题自己提前组织好语言，找一个例子，困难点，最后用的什么方案解决。临时增加需求怎么处理？产品方案明显错误，技术怎么推进？类似这些

### **hr**

这轮基本上保持对这个职位强烈需求就可以了，诸如工作氛围，技术，公司方面都举出很多优点就行。如果你觉得聊下来不行也明确表述你的顾虑，不要浪费互相时间

## **一些面试经验**

和许多面试官交流下来，假如你基础特别好，最多也是一块挑一个问题问，20 分钟就结束了，很少遇到问的十分细，基本按照题库来问打分的，像米哈游，头条，`ucloud`就是这样从题库出题，面试时间控制 30~45 分钟，问的长说明面试官对于你某些方面会有疑问和摇摆，问的短就是挂了。

我也尝试过跟一些候选人交流，发现普遍的一个问题就是好多东西明明知道，却表述不清楚，例如`webpack`整个打包流程是怎么样的，聊聊闭包，箭头函数，`es6`这些基础题，其实这些必问的问题**必须**提前准备，你需要在面试前提前把语言组织好，而不是问到再去想

面试过程注意点：基础题必须答好，有自己的理解，最好答出亮点和项目中实际使用的地方。项目题场景题和面试官求同存异，不一样的地方也不要过分纠结，不同厂有不同的解决方案。编码题最好说出自己的思路，编码这块我做的比较差，要么就是一次写出来，要么直接说不会。最后面试过程中答题一定要自信，我们写代码的肯定是胆大心细，而不是畏手畏脚。



# 单元测试

[前端单元测试技术方案总结](https://juejin.cn/post/6935246645323890724)

[从零开始写单元测试](https://juejin.cn/post/6856754311867826190)

[前端单元测试那些事](https://juejin.cn/post/6844904051449036808#heading-5)

## 通用测试

## chai

## mocha和Jasmin

## jest







# Debug





[HTML 语言简介 - HTML 教程 - 网道](https://wangdoc.com/html/intro.html)

- tabindex 按下 Tab 键，网页的焦点就会从一个元素转移到另一个元素，
- accesskey 属性指定网页元素获得焦点的快捷键，该属性的值必须是单个的可打印字符。只要按下快捷键，该元素就会得到焦点。快捷键是“功能键 + 字符键”的组合。不同的浏览器与不同的操作系统，功能键都不一样。比如，Chrome 浏览器在 Windows 系统和 Linux 系统的快捷键是`Alt + 字符键`

```
<button accesskey="s">提交</button>
```

- hidden
- dir 
	- ltr
	- rtl
	- auto
- contenteditable HTML 网页的内容默认是用户不能编辑，`contenteditable`属性允许用户修改内容。
	- true
	- false
- spellcheck 浏览器一般会自带拼写检查功能，编辑内容时，拼错的单词下面会显示红色的波浪线。`spellcheck`属性就表示，是否打开拼写检查。
	- true
	- false

```html
<p contenteditable="true" spellcheck="true">
英语单词 separate 容易写错成 seperate。
</p>
```

- `data-`属性用于放置自定义数据。如果没有其他属性或元素合适放置数据，就可以放在`data-`属性。 `data-tip`用于放置链接的提示文字。

语义结构

HTML标签的一个重要作用，就是声明网页元素的性质，使得用户只看标签，就能了解这个元素的意义，阅读 HTML 源码就能了解网页的大致结构。这被称为 HTML 的语义原则。

- header 页眉
- footer 页尾
- main  页面内容的主体内容
- article // 表示一篇文章或者一个论坛帖子 文章
- aside // 侧边栏  放置与网页或文章主要内容间接相关的部分
- section  主题的独立部分
- nav 放置页面或文档的导航信息
- h1~h6
- hgroup 主标题包含多级标题（比如带有副标题）

```html
<body>
  <header>页眉</header>
  <main>
    <article>
      <h1>文章标题</h1>
      <p>文章内容</p>
    </article>
  </main>
  <footer>页尾</footer>
</body>

<article>
  <header>
    <h2>文章标题</h2>
    <p>张三，发表于2010年1月1日</p>
  </header>
  <footer></footer>
</article>

<header>页眉</header>
<main>
  <article>文章</article>
</main>
<aside>侧边栏</aside>
<footer>页尾</footer>

<hgroup>
  <h1>Heading 1</h1>
  <h2>Subheading 1</h2>
  <h2>Subheading 2</h2>
</hgroup>
```

- `<wbr>`标签跟`<br>`很相似，表示一个可选的断行。如果一行的宽度足够，则不断行；
- hr 水平线
- `<pre>`是一个块级元素，表示保留原来的格式（preformatted），即浏览器会保留该标签内部原始的换行和空格。浏览器默认以等宽字体显示标签内容。
- `<u>`标签是一个行内元素，表示对内容提供某种注释，提醒用户这里可能有问题，基本上只用来表示拼写错误。浏览器默认以下划线渲染内容。`<s>`标签是一个行内元素，为内容加上删除线。

<u>123123123<s>123123123123</s></u>

- `<blockquote>`是一个块级标签，表示引用他人的话
- `<cite>` 和 `p` `<q>`是一个行内标签，也表示引用

```
<p>
  莎士比亚的《哈姆雷特》有一句著名的台词：
  <q cite="https://quote.example.com">活着还是死亡，这是一个问题。</q>
</p>
```

- 多行代码，`<code>`标签必须放在`<pre>`内部。`<code>`本身仅表示一行

```html
<pre>
	<code>
	
	</code>
</pre>
```

- `<kbd>`标签是一个行内元素，原意是用户从键盘输入的内容，现在扩展到各种输入，包括语音输入。浏览器默认以等宽字体显示标签内容。`<samp>`标签是一个行内元素，表示计算机程序输出内容的一个例子。浏览器默认以等宽字体显示。

- `<mark>` 行内标签 表示突出显示的内容
- `<small>` 行内标签 文章附带的版权信息或法律信息
- `<time>`，`<data>`

```html
<p><time datetime="2018-09-23"></p>
<data>标签与<time>类似，也是提供机器可读的内容，但是用于非时间的场合。
```

- `<address>` 标签是一个块级元素 表示某人或某个组织的联系方式
- `<addr title="HTML"></addr>`
- `<ins>` 和 `<del>`
- `<bdo>` 和 `<bdi>`

```html
// <bdo>标签是一个行内元素，表示文字方向与网页主体内容的方向不一致。
<p><bdo dir="rtl">霜上地是疑</bdo></p>
    // ltr表示从左到右，rtl表示从右到左。
```

- ol > li 有序列表
	- reversed 倒序
	- start =“5” 起始编号 整数，表示数字列表的起始编号
	- type
		- `a`：小写字母
		- `A`：大写字母
		- `i`：小写罗马数字
		- `I`：大写罗马数字
		- `1`：整数（默认值）
- ul  > li  无序列表
- dl  （description  list）dt（term） dd  （detail）

```

```





[CSS 参考手册](https://www.w3school.com.cn/cssref/index.asp)

[CSS CSS3手册_CSS3中文手册](https://www.xp.cn/css3/)

[JavaScript 教程 - 网道](https://wangdoc.com/javascript/)

[ES6 教程 - 网道](https://wangdoc.com/es6/)

[jQuery 教程](https://www.w3school.com.cn/jquery/index.asp)

[Web API 教程 - 网道](https://wangdoc.com/webapi/)

[安装 | Vue.js](https://vue-docs-next-zh-cn.netlify.app/guide/installation.html#vue-devtools)

[webpack](https://webpack.docschina.org/)

[Node.js 简介](http://nodejs.cn/learn)

[axios中文网|axios API 中文文档 | axios](http://www.axios-js.com/)

[AJAX 教程](https://www.w3school.com.cn/ajax/index.asp)

[ESLint - 插件化的 JavaScript 代码检测工具 - ESLint中文文档](https://eslint.bootcss.com/)

[Babel 中文网 · Babel - 下一代 JavaScript 语法的编译器](https://www.babeljs.cn/)

[MySQL 入门教程 - 用代码书写人生 - 博客园](https://www.cnblogs.com/webnote/p/5753996.html)

[Express - 基于 Node.js 平台的 web 应用开发框架 - Express 中文文档 | Express 中文网](https://www.expressjs.com.cn/)

[Koa (koajs) -- 基于 Node.js 平台的下一代 web 开发框架 | Koajs 中文文档](https://koa.bootcss.com/)

[React 官方中文文档 – 用于构建用户界面的 JavaScript 库](https://react.docschina.org/)

[Element - The world's most popular Vue UI framework](https://element.eleme.cn/#/)



[前端该如何准备数据结构和算法？](https://juejin.cn/post/6844903919722692621)





# 面试

## 面试题





## 刷题

LeetCode





面试题

### 笔试



### 机试



### 手写代码

[1.1 学习说明_【前端工程师面试宝典】学习说明_互联网校招面试真题面经汇总_牛客网](https://m.nowcoder.com/tutorial/96/f5212664ab664984882b00635066ded2)

