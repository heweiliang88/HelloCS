---
title: 前端常用开发命令
categories:
- 前端
tags:
- 常用命令
abbrlink: 61107

---

# 常用命令

## backage

- vue、vue-cli、vue-router、vuex、axios
- webpack
- jquery
- json5

```bash
// vue 2.0
npm i @vue/cli-g  //vue-cli

//vue 3.0
npm install vue@next  //
npm install -g @vue/cli@next  // yarn global add @vue/cli@next
// Vue 3 你应该使用 npm 上可用的 Vue CLI v4.5 作为 @vue/cli@next

//vite
npm init vite-app <project-name>
yarn create vite-app <project-name>

vue -V
npm install -g @vue/cli @vue/cli-service-global
```

```bash
npm install elementui
```

```
npm install webpack -g
```

vue 必备插件

```
// sass、less、stylus
npm install -D sass-loader node-sass
npm install -D less-loader
npm install -D stylus-loader stylus

npm install vue-router 

npm install vuex

npm install axios -S

g：全局安装。表明这个包将安装到你的计算机中，你可以在计算机任何一个位置使用它。
--save/-S：通过该种方式安装的包的名称及版本号会出现在 package.json 中的 dependencies 中。dependencies 是需要发布在生成环境的。例如：ElementUI 是部署后还需要的，所以通过 -S 形式来安装。
--save-dev/-D：通过该种方式安装的包的名称及版本号会出现在 package.json 中的 devDependencies 中。


// 懒加载
npm install vue-lazyload -S

npm list：查看当前目录下都安装了哪些 npm 包。
npm info 模块：查看该模块的版本及内容。
npm i 模块@版本号：安装该模块的指定版本。
```

```bash
vue create <project-name>

vue add element
```

## git

```bash
git clone
git pull
git push

```

## nvm

[nvm-sh/nvm: Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions](https://github.com/nvm-sh/nvm)

[安装nvm]([nvm-sh/nvm: Node Version Manager - POSIX-compliant bash script to manage multiple active node.js versions](https://github.com/nvm-sh/nvm))

[(...) win10安装nvm踩坑实录_个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000020112650)

设置环境变量

安装、切换不同Node.js版本的管理器

```bash
nvm ls
nvm install <version> [arch]
nvm install latest 64(默认64位)
nvm uninstall <vesion> [arch]
nvm use <version>
nvm v
nvm list 查看当前安装的Node.js所有版本
nvm install 版本号 安装指定版本的Node.js nvm install latest 最新版本
nvm uninstall 版本号 卸载指定版本的Node.js
nvm use 版本号 选择指定版本的Node.js
```

### node.js 安装

- 第一种直接安装
- 第二种nvm node版本管理工具

#### settings.txt文件的配置

```txt
root: D:\SoftWare\NodeJs\nvm // nvm node版本控制的软件的位置
path: D:\SoftWare\NodeJs\nodejs //当前使用的node的位置
arch: 64 
proxy: none
node_mirror: http://npm.taobao.org/mirrors/node/
npm_mirror: https://npm.taobao.org/mirrors/npm/
```

#### 环境变量的配置

配置nvm和Node.js环境变量

+ NVM_HOME:D:\SoftWare\NodeJs\nvm 
+ NVM_SYMLINK: D:\SoftWare\NodeJs\nodejs 

> nvm不能安装在programs files，因为空格问题，非常不爽
> exit status 1: ‘C:\Program’ �����ڲ����ⲿ���Ҳ���ǿ����еĳ���
> ���������ļ���
>
> 可以通过在nvm根目录将program files替换为 progra~1，如下：
> root: C:\progra~1\nvm
> path: C:\progra~1\nodejs

切换node版本，安装的其他版本安装的全局工具无效

两个重要的目录

> nvm 目录 nvm 管理工具 + v12.16.3 + v13.5.0 （不同的版本）
>
> node.js 目录 （正在使用的node版本）

## node

node的命令行工具

```bash
node  进入REPL环境  REPL : Read、Eval 、print 、Loop
node -v
node -e 'console.log("Hello World")'
node index.js
node path/index.js  // path/index
node --help
.exit 退出 // process.exit()
```

## npm

Node Package Manager

> NPM 出现了两层概念：
>
> - 一层含义是 Node 的开放式模块登记和管理系统，亦可以说是一个生态圈，一个社区。
> - 另一层含义是 Node 默认的模块管理器，是一个命令行下的软件，用来安装和管理 Node 模块。

```bash
npm config get registry
npm install npm -g  // npm install -g npm 

npm update -g nvm
```

## nrm

nrm 是一个 NPM 源管理器，允许你快速地在如下 NPM 源间切换

作用：提供了一些最常用的 NPM 包镜像地址，能够让我们快速的切换安装包时候的服务器地址；
什么是镜像：原来包刚一开始是只存在于国外的 NPM 服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的 NPM 服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样；

```bash
npm install -g nrm  //全局安装`nrm`包
nrm ls // 显示全部镜像 查看当前所有可用的镜像源地址以及当前所使用的镜像源地址
nrm use taobao
nrm test  // 测试镜像速度
```

## cnpm

```bash
npm install cnpm -g
```

## yarn

```bash
npm install yarn -g
yarn config get registry
```

## yrm

yrm 是一个 yarn源管理器，允许你快速地在yarn源间切换

```
npm install -g yrm
yrm ls
yrm use taobao
yrm test  // 测试源的响应时间
```

## cgr

```bash
npm install -g cgr
```

## .vuerc

- loader
- plugins

全局 CLI 配置

- 有些针对 `@vue/cli` 的全局配置，例如你惯用的包管理器和你本地保存的 preset，都保存在 home 目录下一个名叫 `.vuerc` 的 JSON 文件。你可以用编辑器直接编辑这个文件来更改已保存的选项。

- `vue config` 命令来审查或修改全局的 CLI 配置。

```json
{
  "useTaobaoRegistry": true,
  "packageManager": "yarn",
  "presets": {
    "electricity-admin": {
      "useConfigFiles": true,
      "plugins": {
        "@vue/cli-plugin-babel": {},
        "@vue/cli-plugin-router": {
          "historyMode": false
        },
        "@vue/cli-plugin-eslint": {
          "config": "standard",
          "lintOn": [
            "save"
          ]
        }
      }
    }
  }
```

## webpack

```
vue init webpack <project-name>
```

# git

# html5

- 块级元素  `div、h1-h6、ul、ol、li、dl、table、p、hr、form`
- 行内元素 `span、a、img、input、span、textarea、label、select `


- 超文本标记语言
- `<!DOCTYPE html>`   文档声明类型
- head title base link meta script style
- div span p h1~h5  br  a （target id ）  hr   img(src width height alt  align对齐 )
- (strong)b (em)i code sub sup small  ins(插入字) del
- code 代码 kbd 键盘 samp 代码样本 var  变量 pre 预格式文本
- abbr 缩写 address 地址 bdo 文字方向 blockquote 长的引用 q 短的引用语  cite 引用 引证 dfn 定义项目
- 表格 table
  - caption 表格标题
  - table thead tbody tfoot + tr + td
  - table th 标题栏  tr 行  td 列
    - border="0"
    - cellspacing 表格单元格之间的空间
    - cellpadding 单元格与单元格内容之间的距离
  - 合并单元格 作用在 td 上
    - colspan 合并列
    - rowspan  合并行
  - colgroup 表格组
  - col 列属性
- 列表 list
  - 无序列表 ul li
  - 有序列表 ol li
  - 自定义列表 dl dt dd
- 表单 form
  - input 输入框
    - type text  文本域
    - password 密码
    - radio 单选按钮
    - checkbox 复选按钮
    - sumbit 提交按钮
  - textarea 文本域 rows cols
  - fieldset
  - legend
  - select option 下拉列表选项
    - `<option selected="selected">`
  - label  标签
  - button 按钮
  - datalist 输入控件选项列表  keygen  密钥对  output 计算结果
- 符号实体
- iframe src width height  frameborder="0"  class id style title
  - frameset标签 HTML5 不支持 src
  - frame
- media
  - video audio
  - 插件
    - object 插件  插入对象Java 小程序 PDF阅读器 Flash 播放器 `object` data type height width usemap name form
    - embed
- 属性 class id style title

# css3

### css网页特效





- 命令行、Git
- HTML5、
- CSS3、
- BFC、
- 定位、
- 层叠上下文、
- 边距折叠、
- 浮动布局、
- flex布局、
- grid布局、[(29条消息)guid栅格响应式布局_每日一算-CSDN博客_guid布局](https://blog.csdn.net/qq_41828282/article/details/103268972)
- 兼容
- 渲染机制、
- 白屏、
- FOUC、
- 异步加载、
- 重绘与回流、8种数据类型、运算符优先级、箭头函数、声明前置、函数作用域、块级作用域、作用域链、IIFE、递归、递归优化、柯里化、字符串数组方法（ES5/6）、引用类型、深浅拷贝、正则表达式（贪婪、分组、前瞻）

> CSS 和 CSS3常见面试题知识点
>
> - 选择器 ：特殊性、继承、级联
> - 块级元素和行内元素
> - 布局基础：元素、盒模型、BFC、IFC、FFC、浮动及应对方法
> - 字体应用：浏览器如何查找与应用字体
> - 方法论：ITCSS、常见命名方案
> - 常见问题：居中方案（垂直、水平、水平且垂直）、多行文本截断
> - 调试技巧：打印、渲染、标尺

> `> 后代、+ 相邻 、^ 父级兄弟、[] 属性、* 个数 、$ 数字通配符、{} 内容、# id、. class @- 倒序 @3 从3开始 () 分组 .item$@-*5`

行内样式 > 内部样式 > 外部样式 > 导入式（就近原则）

```css
style="color:red;font-size:12px;"
<style type="text/css"></style>
<link href="xxx.css" rel="stylesheet" type="text/css"/>
<style type="text/css"> @import url()；</style>
```

样式表优先级

- (内联样式）Inline style > （内部样式）Internal style sheet >（外部样式）External style sheet > 浏览器默认样式（浏览器缺省数组）

选择器权重

- !important > 内联样式 > ID选择器 > 类\伪类\属性 > 元素\伪元素 > 通配\后代\兄弟 `color:red !important`
- 10000：!important；
- 01000：内联样式；
- 00100：ID 选择器；
- 00010：类选择器、伪类选择器、属性选择器；
- 00001：元素选择器、伪元素选择器；
- 00000：通配选择器、后代选择器、兄弟选择器；

@media、@font-face、@charset、@import 、@keyframes

```css
@charset "UTF-8"
<style type="text/css"> @import url()；</style>
@font-face{}
@keyframes animateName(){}
```

选择器

五大类选择器 `巧记：基层属两伪`

- 基本选择器	5种
- 层次选择器   3种
- 属性选择器
- 伪类选择器 6种  动态目标语言状态结构否定
- 伪元素   4种

基本选择器

| 选择器     | 基本选择器 |
| ---------- | ---------- |
| `E`      | 标签       |
| `#`      | ID         |
| `.class` | 类         |
| `*`      | 通配       |

| 选择器          | 集合选择器                     | 说明           |
| --------------- | ------------------------------ | -------------- |
| `h1,h2,h3{ }` | 分组(群组)选择器（并集选择器） | 多个元素       |
| `h1.red{ }`   | 嵌套选择器（交集选择器）       | 指定类名的元素 |

层次选择器

| 选择器    | 层次选择器                      | 说明                          |
| --------- | ------------------------------- | ----------------------------- |
| `E  F`  | 后代选择器                      | 后代                          |
| `E > F` | 子选择器                        | 子代                          |
|           | 兄弟选择器                      |                               |
| `E + F` | 相邻兄弟(同胞)选择器 同一父元素 | 相邻的同胞元素 (一个 第一个F) |
| `E ~ F` | 通用兄弟选择器 同一父元素       | 后面的同胞元素(多个 F)        |

属性选择器

E[attr=val] = *  ^ & ~ |

| 选择器                              | 说明                                         | 版本                                         |
| ----------------------------------- | -------------------------------------------- | -------------------------------------------- |
| `E[attr]` 属性                    | 指定属性的元素                               | 2                                            |
| `E[attr=val] `属性=值             | 属性等于指定值的元素                         | 2                                            |
| `E[attr*=val] `包含val 字符串     | 属性以指定值(完整单词)开头的元素(不推荐使用) | 3                                            |
| `E[attr^=val] `val开头            | 属性以指定值开头的元素                       | 3                                            |
| `E[attr$=val] `val结尾            | 属性以指定值结尾的元素                       | 3                                            |
| `E[attr~=val] `包含val 有空格隔开 | 属性包含指定值(完整单词)的元素(不推荐使用)   | 2                                            |
| `E[attr                             | =val] `val val-前缀                          | 属性以指定值(完整单词)开头的元素(不推荐使用) |

伪类选择器

动态伪类选择器

（用户行为伪类选择器）active（被激活） hover （停留）focus （获得焦点） （链接伪类选择器）link（未访问）/visited（已访问）

| 伪类选择器         | 作用                                   | 版本 |
| ------------------ | -------------------------------------- | ---- |
| 链接伪类选择器     |                                        |      |
| `:link`          | 选择所有未访问链接                     |      |
| `:visted`        | 选择所有访问过的链接                   |      |
| 用户行为伪类选择器 |                                        |      |
| `:active`        | 选择正在活动链接                       |      |
| `:hover`         | 把鼠标放在链接上的状态 	鼠标悬浮的元素 |      |
| `:focus`         | 元素输入后具有的焦点                   |      |

状态伪类选择器

| 选择器        | 作用     |
| ------------- | -------- |
| `E:checkde` | 选中状态 |
| `E:enable`  | 可选状态 |
| `E:disable` | 禁用状态 |

结构伪类选择器

| 选择器      | 作用                                |
| ----------- | ----------------------------------- |
| `E:root`  | 根元素                              |
| `E:empth` | 没有子元素的元素                    |
| `child`   | fist/last/nth/nth-last-child()/only |
| `of-type` | fist/last/nth/nth-last-child()/only |

| 2*4     | first                                    | last                          | nth                                        | nth-last-child()                              | only                                  |
| ------- | ---------------------------------------- | ----------------------------- | ------------------------------------------ | --------------------------------------------- | ------------------------------------- |
| child   | first-child                              | last-child                    | nth-child(n)                               | nth-last-child(n)                             | only-child（父元素仅有该元素的元素）  |
| of-type | first-of-type(标签中为首的标签) 一组类型 | last-of-type(	标签中为尾标签) | nth-of-type(n)（标签中指定顺序索引的标签） | nth-last-of-type(n)(标签中指定逆序索引的标签) | only-of-type(	父元素仅有该标签的标签) |

一组兄弟元素中其类型的第一个元素。

目标伪类选择器 `:target`

| 伪类选择器 | 作用           |
| ---------- | -------------- |
| ``:target` | 目标伪类选择器 |

语言伪类选择器 `:lang`

`:lang(it)` 带有指定lang属性开始的元素添加样式 ` E:lang[language]`

| 伪类选择器 | 作用               |
| ---------- | ------------------ |
| `:lang`  | 指定标记语言的元素 |

否定伪类选择器 `:not`

| 伪类选择器 | 作用 |
| ---------- | ---- |
| ``:not`    |      |

伪元素 ::

| 符号                  | 伪元素             |
| --------------------- | ------------------ |
| `::first-letter`    | 首字               |
| `::first-line`      | 首行               |
| `::before//::after` | 之前/之后          |
| `::selection`       | 匹配突出显示的文本 |
| `::backdrop`        | 全屏模式的元素     |
| `::placeholder`     | 表单元素的占位     |

列表

list-style

- type : none，disc(实心圆)，circle，square（实心方块），

  - decimal（阿拉伯数字），
  - lower-alpha（小英），upper-alpha，lower-roman，upper-roman（大罗）
- image：图片
- position ：位置

```css
list-style:list-style-type list-image list-position;
list-style:square url('') 0px 10px;
```

盒子

- width | height | min-width | max-width min-width | max-width
  - width | height  实际宽度
  - min 最小值 下限 不低于这个值
  - max 最大值 上限  不高于这个值
- box-sizing
  - border-box IE盒模型
  - content-box w3c盒模型
- margin(外边距) border(边框) padding(内边距) content(内容) outline(轮廓)
  - border:border-color border-style border-width inherit;
  - outline: outline-color outline-style outline-width inherit;
  - margin
  - padding
  - content

内容

border

- border: width style color
- border-radius
- border-image：url()
- box-shadow : *h-shadow v-shadow blur spread color* inset;

  - box-shadow: 10px 10px 5px red insert(内侧阴影);

    box-shadow: 水平阴影位置、垂直阴影位置、模糊距离、阴影大小、阴影颜色、内阴影/外阴影（默认值）；

background 背景

- 2.1 background：color image repeat attachment position;
  - color
  - image
  - repeart 重复 repeat-x repeat-y no-repeat
  - attachment 固定 scroll fixed local
  - position 起始位置top bottom center right left
- 3  background-clip background-origin background-size
  - background-clip 背景裁剪 border-box （剪切成边框方框）padding-box content-box
  - background-origin  背景定位
  - background-size  背景大小

nacgradients 渐变

- background-image: linear-gradient(red blue,0% 100%)
- linear-gradient  线性渐变
- radial-gradient  径向渐变
- repeating-linear-gradient 重复渐变
- conic-gradient 圆锥渐变

```css
linear-gradient(blue, red);
linear-gradient(45deg, blue, red);
linear-gradient(to left top, blue, red);
linear-gradient(0deg, blue, green 40%, red);
```

filter 滤镜

- blur（px）：高斯模糊
- brightness(%) 亮度
- contrast(%)：对比度
- drop-shadow(*h-shadow v-shadow blur spread color*)：投影，常用于给不规则形状进行 阴影效果
- greyscale(%)：灰度
- hue-rotate：色调变换
- opacity(*%*)  透明度
- saturate(*%*) 饱和度
- sepia(*%*)

backgrop-filter 背景滤镜

- 可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）
- none
- filter-function-list  以空格分隔的滤镜函数

```
/* 关键词值 */
backdrop-filter: none;
/* 指向 SVG 滤镜的 URL */
backdrop-filter: url(commonfilters.svg#filter);
/* <filter-function> 滤镜函数值 */
backdrop-filter: blur(2px);
backdrop-filter: brightness(60%);
backdrop-filter: contrast(40%);
backdrop-filter: drop-shadow(4px 4px 10px blue);
backdrop-filter: grayscale(30%);
backdrop-filter: hue-rotate(120deg);
backdrop-filter: invert(70%);
backdrop-filter: opacity(20%);
backdrop-filter: sepia(90%);
backdrop-filter: saturate(80%);
/* 多重滤镜 */
backdrop-filter: url(filters.svg#filter) blur(4px) saturate(150%);
/* 全局值 */
backdrop-filter: inherit;
backdrop-filter: initial;
backdrop-filter: unset;
```

object-fit

- 指定元素的内容应该如何去适应指定容器的高度与宽度
- object-fit: fill|contain |cover|scale-down|none|initial|inherit;

text

- text-shadow 文本阴影
- text-wrap
- white-space 控制空白字符显示
  - normal \|nowrap \|pre \|pre-wrap \|pre-line。因为默认是normal
- word-break 规定非中日韩文本的换行规则。
  - normal \|break-all \|keep-all  如何被拆分换行的
  - word-wrap  word-wrap又叫做overflow-wrap 允许对长的不可分割的单词进行分割并换行到下一行。
- color 文本颜色
- dirction 文本方向
  - ltr 默认
  - rtl 右到左
  - inherit 继承父元素
- letter-spacing 字符间距 letter-spacing  每个汉字（字母）之间的间距
- word-spacing  字间距 word-spacing  每个单词之间的间距，如果是汉字无效
- line-height 行高
- text-align 文本水平对齐方式
- text-decoration  文本添加修饰
- text-transform 字母大小写
- text-indent 文本的首行
- text-overflw 文本超出部分截断
- -webkit-text-stroke 文本描边
- vertical-align 元素的垂直对齐
  - baseline（默认）
  - sub super
  - top text-top middle bottom text-bottom
  - length %（可以是负值） inherit
- writing-mode 文本前进方向
- user-select 不能选中文本

font

- font-family  字体名称
- font-size 文本字体大小
- font-style 字体样式
- font-variant 小型大写字体或者正常字体显示文本
- font-weight 字体粗细
- line-height 行高
- -webkit-font-smoothing 字体清晰
  - -moz-osx-font-smoothing: inherit | grayscale;

display

- dislplay 设置一个元素应如何显示
  - none 元素不再占用空间
  - block
  - inline
  - inline-block
  - flex
  - grid
- visibility 指定一个元素应可见还是隐藏
  - hidden  不可见，但仍占用空间
  - coppapse

opacity

- opacity:0.4; 透明度

overflow

- 控制内容溢出元素框时显示的方式
- visible  超出部分可见
- hidden 超出部分不可见
- scroll 超出部分以滚动条形式显示
- auto
- inherit

clip-path

shape-outside

transparent

- transparent 透明

zoom

- zoom 缩放元素

transform

- transform
- transform-origin 元素位置 (变换中心)
- transform-style  如何在 3D 空间中显示
- translate3d(*x*,*y*,*z*) translate(x,y) translateX(n) translateY(n) 平移
- scale3d(*x*,*y*,*z*) scale(*x*,*y*) scaleX(*n*) scaleY(*n*) 缩放
- rotate3d(*x*,*y*,*z*,*angle*) rotate(*angle*) rotatoX(angle) rotateY(angle) rotateZ(angle) 旋转
- skew(*x-angle*,*y-angle*) skewX(*angle*) skewY(*angle*) 倾斜
- matrix(*n*,*n*,*n*,*n*,*n*,*n*)  matrix3d(*n*,*n*,*n*,*n*,*n*,*n*, *n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*,*n*)
- perspective(*n*)  3D 元素的透视效果。 透视距离
- perspective-origin  3D 元素的底部位置
- backface-visibility 元素在不面对屏幕时是否可见。 物体后方是否可视

transition

- transition : transition-property duration timing-funciton delay
- transtion: 属性 过渡时间 时间曲线 过渡效果结束;
- transition-property 名称
- transition-duration 过渡时间
- transition-timing-function 过渡函数
- transition-delay 过渡效果结束

animations && keyframes

- animation:name dutation timing-function fill-modedelay iteration-count direction play-state;
- animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）
- @keyframe

```css
@keyframes 动画名称{
    0%:{}
    50%:{}
    100%:{}
}
```

bfc

layout

@media

- all、screen、print

```css
@media screen,print{}
```

## CSS 的引入方法

- style
- 外联(link)
- import
- 内嵌

## VFM 视觉格式化模型

- 盒子
  - 盒模型
  - 盒子类型
  - 盒子定位
- BFC(Block Formatting Context）块级格式化上下文
- IFC (Inline Formattong Context)  行内格式化上下文
- FFC(Flex Formatting Contest)  伸缩格式化上下文
- TFC(Table Formatting Context)  表格格式化上下文
- 浮动：清除浮动 (float)

## BFC 块级格式化内容

[(29条消息)什么是BFC？看这一篇就够了_Leon的博客-CSDN博客_bfc](https://blog.csdn.net/sinat_36422236/article/details/88763187)

## 层叠上下文

## 边距折叠

## CSS 阻塞

# js

JavaScript：
继承、原型链、this指向、设计模式、call, apply, bind,；
new实现、防抖节流、let, var, const 区别、暂时性死区、event、loop；
promise使用及实现、promise并行执行和顺序执行；
async/await的优缺点；
闭包、垃圾回收和内存泄漏、数组方法、数组乱序, 数组扁平化、事件委托、事件监听、事件模型

- JavaScript = 基础 + 对象 + BOM + DOM + ES6

js基础

- 变量 和 常量  语句 分号
- 代码 和 代码块
- 运算符  算术 赋值 条件 比较 逻辑
- 关键词 标识符
- 语句标识符
- 注释
- 数据类型 数字 字符串 数组 对象
- 字面量 数字字面量(Number) 字符串字面量（String）表达字面量 数组字面量（Array） 对象字面量(Object ) 函数字面量（Function）

事件

[JavaScript 教程 - 网道](https://wangdoc.com/javascript/index.html)

[分类：JavaScript - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/javascript/)

ajax 的优点（异步JavaScript和XML）

- 无刷新更新数据。
- 异步与服务器通信。
- .前端和后端负载平衡。
- 基于标准被广泛支持
- 界面与应用分离。

缺点

- AJAX干掉了Back和History功能，即对浏览器机制的破坏。
- AJAX的安全问题。（SQL注入攻击和基于Credentials的安全漏洞等等。）

单位

[前端用到的那些单位 - 简书](https://www.jianshu.com/p/f9b34885609d)

- px  像素，相对长度单位
- rpx x单位是微信小程序中css的尺寸单位，rpx可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。
  - rem和rpx的换算关系：rem: 规定屏幕宽度为20rem；1rem = (750/20)rpx
- em 相对长度单位。它没有一个固定数值，支持小数点后三位数
- rem CSS3新增的一个相对单位（root em，根em）
- vh、vw、vmax、vmin 视口指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。
- ch
- ex

max-widht miw-

字体变的更清晰CSS 中

- -webkit-font-smoothing控制的字体渲染只对MacOS的Webkit有效。

移动 H5 端兼容解决方案

[手把手带你把项目改为移动端适配｜技术点评](https://juejin.cn/post/6937559206413205512)

适配方案

- media queries (媒体查询)

  - 布局

    ```
    @media only screen and (max-width: 500px) {
        body {
            background-color: lightblue;
        }
    }
    ```
- rem（font size of the root element）对于根元素的字体大小的单位。简单的说它就是一个相对单位，rem 计算的规则是依赖根元素。原理是先按定高宽设计出来页面，然后转换为 rem 单位，配合 js 查询屏幕大小来改变 html 的 font-size
- flex 或者百分比布局 Flex
- viewport 指的是移动设备浏览器中放置页面的一个虚拟的窗口，该窗口可大于或小于移动设备的可视区域。

  - width=device-width ：表示宽度是设备屏幕的宽度
    initial-scale=1：表示初始的缩放比例
    minimum-scale=1：表示最小的缩放比例
    maximum-scale=1：表示最大的缩放比例
    user-scalable=no：表示用户是否可以调整缩放比例
- viewport
- 布局 用 flex 单位 rem
- 页面存在写死的宽度 ==> 改成百分比
- 页面多处使用绝对定位 和 浮动

H5项目可用的框架

- bootstrap
- MUI SUI
- vuex
- weex
- Mint UI

微信小程序生命周期

- 5 应用生命周期
  - onLaunch(初始化)、onshow(启动或切前台)、onHide(切后台)、onError(错误监听)、onPageNotFound(不存在监听函数)
- 12 页面生命周期
  - data(初始化数据)、onLoad(页面加载)、onShow(页面显示)、onReady(初次渲染)、onHide(页面隐藏)、onUnload(页面卸载)
  - onPullDownRefresh(上拉动作)、onReachBottom(上拉触底事件)、onShareAppMessage(右上角转发)、onPageScroll(滚动触发事件的处理函数)、onResize(页面存储触发、响应显示区域变化)、onTabitemTap(tab页)

vue 的UI 库

PC

[2020年 16 个最有用的 Vue UI库 - SegmentFault 思否](https://segmentfault.com/a/1190000021876315)

- element-ui
- ootstrap Vue
- Mint UI
- Vuetify
- Quasar Framework

H5

微信小程序的框架(多端小程序)

- 原生 weui
- Taro  react
- wepy
- uni-app vue
- mpvue vue
- wepy
- omi

vue 生命周期

1、beforeCreate（创建前）

2、created（创建后）

3、beforeMount（载入前）

4、mounted（载入后）

5、beforeUpdate（更新前）

6、updated（更新后）

7、beforeDestroy（销毁前）

8、destroyed（销毁后）

后三个不常用

activated

deactivated

errorCaptured

[一年前端面试指南（万字详细答案） - 掘金](https://juejin.im/post/6865600010570989582#heading-0)
[前端进阶必经之路（一）：1.2w字深入理解JavaScript26个核心概念 - 掘金](https://juejin.im/post/6865184344990810126#heading-57)
[由浅入深，66条JavaScript面试知识点 - 掘金](https://juejin.im/post/6844904200917221389)

## JS 运行环境

- Node
- 浏览器
  浏览器内核分为两种：渲染引擎 和 js 引擎
- 渲染引擎：负责网页内容呈现的
- JS引擎：解析js脚本，实现JS交互效果

## 设计模式

## 原型及原型对象

## 作用域与作用域链

<details>   <summary>Click Here to get the user details</summary>   <table>     <tr>       <th>#</th>       <th>Name</th>       <th>Location</th>       <th>Job</th>     </tr>     <tr>       <td>1</td>       <td>Adam</td>       <td>Huston</td>       <td>UI/UX</td>     </tr>   </table> </details>
<h2> Shoppping List(Content Editable) </h2> <ul class="content-editable" contenteditable="true">     <li> 1. Milk </li>     <li> 2. Bread </li>     <li> 3. Honey </li> </ul>

## 闭包

## ES6 Class 语法

## JS  继承

通过继承我们可以使子类具有父类的各种方法和属性，避免了代码的重复输出

## JS 原型链、构造器、原型

## 异步编程

## 内存泄露，优化方法

## 防抖 节流

## 跨域

## 高阶函数和柯里化

柯里化
定义：是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术

## promise

## ES6模块化

## 深拷贝和浅拷贝

## 函数防抖和节流

[防抖、节流 | Shawnchen / XMU 。](http://alloween.top/2018/04/16/%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81/)

### 防抖（debounce）

作用是在 ``短时间``多次触发 `同一个函数`，只执行最后一次，或者只在开始执行

### 节流（throttle）

类似于防抖，  节流是在一段时间内只允许函数执行一次

## 时间戳

时间戳是使用[数字签名](https://baike.baidu.com/item/数字签名/212550)技术产生的数据，签名的对象包括了原始文件信息、签名参数、签名时间等信息。时间戳系统用来产生和管理时间戳，对签名对象进行数字签名产生时间戳，以证明原始文件在签名时间之前已经存在。
[Unix时间戳(Unix timestamp)转换工具 - 站长工具](https://tool.chinaz.com/tools/unixtime.aspx)
Unix 时间戳  可以转变成指定的 时间

```
Unix 时间 1997128290
2033/4/15 5:51:30
```

获取现在的Unix时间戳(Unix timestamp)

```JavaScript
Math.round(new Date().getTime()/1000)
getTime()返回数值的单位是毫秒
```

实现Unix时间戳(*Unix timestamp*) → 普通时间

```javascript
先 var unixTimestamp = new Date(Unix timestamp * 1000) 然后 commonTime = unixTimestamp.toLocaleString()
```

实现普通时间 → Unix时间戳(*Unix timestamp*)

```javascript
var commonTime = new Date(Date.UTC(year, month - 1, day, hour, minute, second))
var commonTime = new Date(Date.UTC(2090, 1, 23, 3, 34, 23))
Thu Feb 23 2090 11:34:23 GMT+0800 (中国标准时间)
```

## AJAX发送数据请求

## 前端跨域问题

[前端跨域问题 | Shawnchen / XMU 。](http://alloween.top/2017/06/19/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/)

### vue 有多少个生命周期？

vue 有十一个生命周期

常用生命周期：

- beforeCreate
- created
- beforeMount
- mounted
- beforeUpadate
- upadate
- beforeDestory
- destory

不常用生命周期

- activated
- deactivated
- errorCaptured

### 微信小程序生命周期

- 5个应用生命周期：onLaunch(初始化)、onShow、onHide(显示隐藏)、onError(错误监听)、onPagNotFound(页面不存在)
- 12个页面生命周期：
  - data(初始数据)、onLoad(加载)、onShow、onHide(显示隐藏)、onReady (渲染完成) 、onUnload(页面卸载)
  - onPullDownRefresh(上拉动作)、onReachBottom(上拉触底事件)、onShareAppMessage(右上角转发)、onPageScroll(滚动触发事件的处理函数)、onResize(页面存储触发、响应显示区域变化)、onTabitemTap(tab页)

### 面试一

ajax的优点和缺点?

> [AJAX工作原理及其优缺点 - SanMaoSpace - 博客园](https://www.cnblogs.com/sanmaospace/archive/2013/06/15/3137180.html)

- ajax 是什么
  - AJAX (Asynchronous JavaScript and XML) 异步的Javascript和XML，是一种创建交互式网页应用的网页开发技术。
- 类似ajax的库
  - axios
  - fetch
  - jquery
  - request
- 优点
  - 无刷新更新数据
  - 异步与服务器通信
  - 前端和后端 ``负载均衡``
  - 基于标准被 ``广泛支持``
  - 界面与应用分离
  - 支持异步处理
- 缺点
  - 干掉了Back和History功能，即对 ``浏览器机制的破坏 Back History ``
  - 浏览器不兼容
  - 不安全 问题 SQL注入攻击
  - 对搜索引擎支持较弱
  - 破坏程序的异常处理机制
  - 违背URL和资源定位的初衷
  - 不能很好支持移动设备
  - 客户端过肥，太多客户端代码造成开发上的成本
  - 增加Web服务器的负载
- 使用场景
  - 表单驱动的交互
  - 深层次的树的导航
  - 快速的用户与用户间的交流响应
  - 类似投票、yes/no等无关痛痒的场景
  - 对数据进行过滤和操纵相关数据的场景
  - 普通的文本输入提示和自动完成的场景
- 不适用场景
  - 部分简单的表单
  - 搜索
  - 基本的导航
  - 替换大量的文本
  - 对呈现的操纵

```html
<div id="myDiv"><h2>使用 AJAX 修改该文本内容</h2></div>
<button type="button" onclick="loadXMLDoc()">修改内容</button>
```

```js
// new XMLHttpRequest  ==> onreadystatechange  xmlhttp.readyState==4 && xmlhttp.status==200  ==> xmlhttp.open() ==> xmlhttp.send()
function loadXMLDoc()
{
    // XMLHttpRequest ActiveXObject("Microsoft.XMLHTTP")
	var xmlhttp;
	if (window.XMLHttpRequest)
	{
		//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
		xmlhttp=new XMLHttpRequest();
	}
	else
	{
		// IE6, IE5 浏览器执行代码
		xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}
	xmlhttp.onreadystatechange=function()
	{
		if (xmlhttp.readyState==4 && xmlhttp.status==200)
		{
			document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
		}
	}
	xmlhttp.open("GET","/try/ajax/ajax_info.txt",true);
	xmlhttp.send();
}
```

js 和 == 和 === 的区别是什么

> [js 中 == 和 === 的区别](https://juejin.cn/post/6844903456407289869)

- "``==``"叫做相等运算符，"``===``"叫做严格运算符
- `===` 严格相等，会比较两个值的类型和值
- `==`  抽象相等，比较时，会先进行类型转换，然后再比较值
- 尽量使用严格运算符 ===。因为"=="不严谨，可能会带来一些违反直觉的后果

v-if 和 v-show 的区别 是什么

- v-if
  ----
- v-show
  ------

v-loader是什么？有什么作用？

> [vue-loader是什么？使用它的用途有哪些 ](https://www.cnblogs.com/dream111/p/13498766.html)

- 是什么：vue-loader会解析文件，提取出每个语言块，如果有必要会通过其他loader处理，最后将他们组装成一个commonjs模块；module.exports出一个vue.js组件对象
- 作用： vue文件   template  script style `.vue结尾的组件` ==> html文件
  - template **语言块**  html
    - 最多包含一个< template>块
  - scirpt js
    - 最多包含一个< script>块
  - style css
    - scoped
    - 可以包含多个< style>标签
  - 自定块
    - 在.vue文件中添加额外的自定义块来实现项目的特殊需求 < docs>块

Vuex中 `$set`在什么时候使用

vue传递参数的2种方式

vue-router 跳转和 location.href跳转的区别

4种

:before、:after

让页面的字体变清晰，变细，用CSS怎么做？

### 面试二(网上面试)

你了解的vue 组件库

H5

HBuilder的使用

微信小程序框架

移动端兼容方案？

### 面试三

vue 生命周期有几个？分别

keep-alive

什么是跨域？怎么解决跨域

你刷新页面表单保存状态

var 、let 和 const的区别

### 面试五

ES6 promise的用途、用法

ES6  async

ES6 各个新增函数

vue 父子组件之间通讯（组件之间通信）

父传子

1. props

```

```

子传父

- `emit`

子子

vuex  组件间通信

vue 的生命周期函数

- beforeCreate created
- beforeMount mounted
- beforeUpdate updated
- beforeDestory destory

vuex 是什么? 怎么使用? 那种功能场景使用它？

vue-show和v-if指令的共同点和不同点？

vue路由 `$router` 和``$router`的区别？

微信小程序从创建到开发到线上的整理流程？

微信小程序有哪些生命周期，它们具体作用？

let arr = [ {id,}]

vuex

vue-router

common.js ant.js

面试题

html

Doctype作用，HTML5 为什么只需要写 `` <!DOCTYPE HTML>``

- Doctype 是

行内元素有哪些，块级元素有哪些，空(void)元素有那些

- 行内元素
- 块级元素
- 空元素

HTML语义化的理解

浏览器内核有哪些，介绍一下你对浏览器内核的理解

html5有哪些新特性

 cookie，sessionStorage 和 localStorage 的区别

浏览器内多个标签页之间的通信

HTML5的离线存储怎么使用，解释一下工作原理

css

js

ajax

[vue常见面试题 - 随笔分类(第3页) - 大牛半路出家 - 博客园](https://www.cnblogs.com/dream111/category/1827604.html?page=3)

[vue视频教学 · 前端面试题精编（微信小程序（基础到高级）js视频资源、vue/js/html/css/React/ES6面试题、算法、插件大全）（轻松面对面试）（持续更新） · 看云](https://www.kancloud.cn/lemon-m/js-html-css/998118)

vue

vue

说出几种vue当中的指令和它的用法？

- v-html 渲染为html元素
- v-text 渲染
- v-if  根据表达式的值的真假条件渲染元素
- v-show 根据表达式之真假值，切换元素的display CSS 属性
- v-for 循环指令，基于一个数组或者对象渲染一个列表
- v-bind:class 动态地绑定一个或多个特性，或一个组件prop 到表达式
- v-on 用于监听指定元素的事件
- v-once 渲染一次
- v-model 数据双向绑定

vue-router

vuex

vuex有几种属性

- state 、getter、mutation、action、module
  - state ==> 数据存储、数据源、基本数据
  - getter ==>

mvvm mvc mvp mvvm

## 防抖节流

防抖:防止用户手抖多次进行操作

- 触发事件
- setTimeout
- clearTimeout

使用场景

- 改变页面大小的统计
- 滚动页面位置的统计
- 输入框连续输入的请求次数控制

```js
// 防止点击按钮多次提交
<button>按钮</button>
<button>按钮1</button>

var btn = document.getElementsByTagName('button')[0]
var btn1 = document.getElementsByTagName('button')[1]

fucntio payMoney(){
    console.log('已经付款')
}

// 防抖
funciton debounce(func,delay){  // 方法作为参数
 	let timer;
    return function(){ // 高阶函数 函数里面返回函数
        let content = this // this 的情况
        let args = argments
        clearTimeout(timer);
        timer = setTimeout(function(){
           func.apply(content,arguments);
        },delay)
    }
}

btn.addEventListener('click',debounce(payMoney,1000))
btn1.addEventListener('click',debounce(payMoney,1000))
```

节流

滚动屏幕

- 需要统计用户滚动屏幕的行为来做出相应的网页反应
- 不断请求 ==》 响应不断增加 ==》导致网络阻塞

## CSS 三角形

```css
width:0;
height:0;
border:125px solid black 125px solid black 125px solid black 0 solid black;
margin: 0 auto;
```

## 图片懒加载

> [前端性能优化——图片篇](https://juejin.cn/post/6965761736083243044)

图片懒加载和预加载

```html
<img data-src="photo.png">
<img data-src="photo1.png">
<img data-src="photo2.png">
```

```js
const images = document.querySelectorAll('img');

const callback = entries =>{
      //console.log(entries) // entries 数组
      //console.log('runing!!!')
     //entries.forEarch(entry =>{
       //  console.log(entry); // 是否交叉 可视区域
     //})
    if(entry.isIntersecting){
        const imgage = entry.target;
        const data_src = image.getAttribute('data-src')
        imge.setAttribute('src',data_src)
        observe.unobserve(image)
        console.log('触发事件！！！')
    }
}

const observe = new IntersectionObserver(callback); //callback 看见了触发 看不见了不触发
// observe.observe(DO节点)
// observe.unobserve(DOM节点)

imges.forEarch(images =>{
     observer.observe(image);
})
```

## 宏任务和微任务

- javascript 是单线程的。也就是只用一个调用栈。调用栈按照先入后出的规则进行的，一次调用一个可以嵌套。在执行调用栈的时候会先执行同步的任务。调用栈在发生异步任务的时候会放进队列里面。异步任务队列分为宏任务队列（硬菜）和微任务队列（软菜）。队列是按照先入先出的规则。
- 宏任务队列，新程序或子程序被直接执行 ，`script`元素里面的代码  事件的回调函数 setTimeout() 和 setInterval() 函数、requestAnimationFrme I/O 操作 setImmediate UI rendering等等
- 微任务队列，Promise() then() catch() finally() 、MutationObserver 、Object.observe、process.nextTick()
- 运行，Event Loop 事件循环 事件循环是一个不断进行的循环的机制。事件循环会不断去寻找可执行的任务来执行
- 先执行调用栈 清空 ==> 微任务队列 清空 `promise` ==> 宏任务队列 `setTimeout`
- 调用栈  队列（宏任务队列 和 微任务队列 ）

```js
// 1、script标签（宏任务） 分派是 宏任务队列 和 微任务队列 清空调用栈
// 2、先微任务（优先）（清空）==> 渲染 ==》  宏任务（如果还有微任务重新开始） 【事件循环】

console.log('1');

setTime(function(){
    console.log('2');
},0)

Promise.resolve().then(()=>{
  console.log('3')
})

setTime(function(){
    console.log('5');
},0)

console.log('4')

// 1 4 3 2 5
```

## 深浅拷贝

## Promise

Promise 两种结果 基本形式 异步处理防止阻塞

- 如果没有Promise 只有单纯的回调，多个回调重叠在一起就会产生回调地狱的现象
- 成功 resolve() ==》 then  表示成功

  - finally  最终
- 失败 reject()  ==> catch 捕获失败

```js
const isPregnant = false;

const promise = new Promise((resolve,reject){
	if(isPregnant){
    	resolve('成功')
	}else{
        reject('失败')
    }
})

promise.then(name =>{
    		console.log(nane)
		})
       .catch(name =>{
    		console.log(name)
		})
	   .finally(()=>{
       		console.log('最终成功了')
		})
```

```js
const imgAddress = 'https://www.baidu.com/img/540x258_2179d1243e6c5320a8dcbecd834a025d.png'

const imgPromise = (url) => {
    return new Promise((resolve,reject)=>{
        const img = new Image();
        img.src = url;
        img.onload = () =>{
            resolve(img)
        };
        img.onload = ()=> {
            reject(new Error('图片错误'));
        };
    })
};

imgPromise(imgAddress)
	.then(img =>{
    	document.body.appendChild(img)
	}).catch(err =>{
    	document.body.innerHTM = err
	})
```

```js
const promise = new Promise();

// resolve().then()
promise.resolve(()=>{

}).then(()=>{

}).finally(() =>{

})

// reject().catch()
promise.reject(()=>{

}).then(()=>{

}).finally(() =>{

})
```

## 函数柯里化

- 解决重复参数 使用柯里化技术可以很好的复用

```js
function uri(protocol,hostname,pathname){
    return `${protocol} ${hostname} ${pathnane}`
}

const uri1 = url('https://','www.danlaoshi.com'.'/dir');
console.log( uri1)

function url_curring(protocol){
    return function(hostname,pathname)
          return `${protocol} ${hostname} ${pathnane}`
    }
}

const uri_https = url_curring('https://');
const uri2 = uri_https('www.baidu.com','/hello')
const uri3 = uri_https('www.baidu.com','/hello2')
const uri4 = uri_https('www.baidu.com','/hello3')

console.log(url2,url3,url4)
```

```js
funciton add(){
  let args = Array .prototype.slice.call(arguments);
  let inner = function(){
  	args.push(...arguments);
  	return inner;
  }
  inner.toString = function(){
 	return args.reduce(function(pre,cur){
        return prev + cur
    })
  }
    return inner;
}

const result = add(1)(2)(3)(4)
console.log(result)
```

## 创建对象的多种方法

- 以名值对的方式存储的
- Object 是所有对象的基类

```js
// 创建方法一
let obj = new Object(); // 创建实例
obj.eat = ['1','2','3']; // 逐个添加属性和方法
obj.effect = function(){
    console.log()
}

// 对象字面量
let obj= {
    eat:['1','2','3'],
    effect:function(){

	}
}

// 工厂模式 对象没法标识
function person(name,age){
    let obj = new Object();
    obj.name = name
    obj.age = age
    obj.func = funciton(){
        console.log(this.name)
    }
    reutnr obj
}
let  p1 = Person('hwl',20);
let p2 = Person('nh',30)

p1.func()
问题
console.log(p1 instanceof Person) //false 没有关联

// 构造函数模式
function Person(name,age){ // 大写
    this.name = name  // this指向
    this.age = age
    this.func = funciton(){
        console.log(this.name)
    }
}
let  p1 = new Person('hwl',20); // new 隐式的创建对象 并且返回对象
let p2 = new Person('nh',30)

p1.func()
console.log(p1 instanceof Person)


let mlr2 = Object.create(mlt)
mlt.vegetable.push('内容')


class MLT(){
    constructor(a,b,c){
        this.a = a
        this.b = b
        this.c = c
    }
}
```

## 原型到原型链

## 执行上下文栈

## 变量对象

## 作用域链

## 执行上下文

## 闭包

## call 和 apply 和 apply

## 箭头函数

- 函数表达式 匿名的
- 普通函数 函数表达式 函数声明

```
function(){}

()=>{}
一个参数 不用（） 一个表达式 不用 {}
```

## 继承

## 类class

js高级

DOM

HTML DOM

- document.getElementById ](id)
-

BOM

- window
  - alert
- document
  - write
- screen
- navigator
- history
  - back
  - go
  - length
- console

# ajax

异步请求 XMLHttpRequest

### 优点

最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。
使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。
可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求。
基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。

# fetch

> [Fetch API 教程 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html)

fetch()是XMLHttpRequest 的升级版。用于在 JavaScript 脚本里面发出 HTTP 请求。

- 使用Promise，不使用回调函数
- 模块化设计
- 通过数据流处理数据，分块读取

```js
fetch(url).then().catch()

// Promise
fetch('http://192.168.1.15:3000/search?keywords=%E6%B5%B7%E9%98%94%E5%A4%A9%E7%A9%BA')
  .then(response => response.json())
  .then(json => console.log(json))
  .catch(err => console.log('Request Failed', err));

// async await

```

Response

- ok
- status
- statusText
- url
- type
- redirected
- headers

```js
{	// data 由服务器提供的响应 数据    data:{},    // status HTTP 状态码    status:200,    //  statusTest 来自服务器响应的HTTP状态信息    statusText:"OK",    // headers 服务器响应的头信息    headers:{},    body:{}       // config 是为请求提供的配置信息    config:{}}
```

# axios

axios api

- axios(config)，axios(url,[,config])，axios({ method,url,data })

```js
axios({
    method:'post',
    url:'',
    data:{
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
})
axios('url')  == axios.get('url')
axios('',{ key:value,key2,value2 }).then((res) =>{}).catch((err) =>{})
```

常用方法

axios 组成部分

- 方法部分
- axios 依赖原生的 ES6 Promise 实现 axios的安装依赖于vue
- axios.get url 传递参数

```js
axios.get('/user?ID=123').then(res => {}).catch(err=>{})
axios.get('/user',{ params:{ ID :123}}).then().catch()
// 相当于 GET请求 默认的方法
axios('url')
```

- axios.post

```js
axios.post('/user',{ firstName: 'Fred'，lastName: 'Flintstone' }).then( res =>{}).catch( err =>{})
```

- axios.create
- 数据处理部分
- then( res => {} )
- 错误处理部分
- catch()

请求方法别名 实例方法

- axios()

```
axios.get、post、put、patch、deleterequest headaxios.request(config)axios.get(url[, config])axios.delete(url[, config])axios.head(url[, config])axios.post(url[, data[, config]])axios.put(url[, data[, config]])axios.patch(url[, data[, config]])request、get、post、put、head、patch、delete
```

并发 处理并发请求的助手函数 `all() 和 spread()`

- axios.all([fuc(),fuc()])  并发请求  axios.all([fuc(),fuc()]).then().catch()

```js
axios.all([getUserAccount(),getUserPremission()]).then(axios.spread(function(acct,perms){    // 两个请求现在都执行完成}))
```

- axios.spread(callback)

配置

- axios.create([config])
- axios.defaults.xxx

```js
axios.create([config]);const instance = axios.create({	baseURL = '',	timeout:1000,  // 超时时间	headers: {'X-Custom-Header': 'foobar'} //头信息};                              // 配置默认值// 创建实例设置默认配置的默认值axios.defaults.baseURL = 'https://api.example.com';  //默认URLaxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;  // headersaxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; //postvar instance = axios.create({	baseURL:'https://api.example.com'})// 在实例已创建后修改默认值instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;// 配置优先级// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`var instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置 get 请求instance.get('/longRequest', {  timeout: 5000});
```

拦截器 `interceptors`

- axios.interceptors.request.use
- axios.interceptors.response.use
- axios.interceptors.requeset.eject 移除

```js
// 添加请求拦截器axios.interceptors.request.use(	function (config){		return config;	},function(error){		return Promise.reject(error);	}});// 添加响应拦截器axios.interceptors.response.use(	function (config){		return config;	},function(error){		return Promise.reject(error);	}})// 移除拦截器 `axios.interceptors.requeset.eject`var myInterceptor = axios.interceptors.request.use(function(){});axios.interceptors.requeset.eject(myInterceptor);// interceptors.use/eject //``自定义axios 实例``添加拦截器var instance = axios.create();	instance.interceptors.request.use(function(){})
```

取消 ` cancel token 取消请求`

- axios.CancelToken

```js
var CancelToken = axios.CancelToken;var source = CancelToken.source();axios.get('/user.12345',{	cacelToken:source.token}).catch(function(thrown){	if(axios.isCancel(thrown)){		console.log('Requst canceled',thrown.message)	}else{	}}})source.cancel
```

错误处理  `validateStatus`

- validateStatus

```js
// 状态码
 axios.get('/user/12345',funciton(){	validateStatus:funciton(status){		return status < 500  // 状态码在大于或等于500时才会 reject	}})axios.get().catch(	function(error){      if(error.response){		console.log(error.response.data);		console.log(error.response.status);		console.log(error.response.headers);        }else{            console.log(’Error‘,error.message);        }        console.log(error.config);    })
```

# jquery

> [jQuery API 中文文档 | jQuery 中文网](https://www.jquery123.com/)
>
> [jQuery 参考手册](http://www.w3school.me/jquery/jquery-ref-selectors.html)

```
$.fn.jquery$(this) == this
```

| 鼠标事件                | 键盘事件               | 表单事件                                 | 文档/窗口事件                                                   |
| ----------------------- | ---------------------- | ---------------------------------------- | --------------------------------------------------------------- |
| `click`               | `keypress 键被按下`  | `submit 提交`                          | `load 指定的元素已加载`                                       |
| `dbclick`             | `keydown 按下的过程` | `change 元素的值改变,仅适用于表单字段` | `resize 调整浏览器窗口大小`                                   |
| `mouseenter 鼠标进入` | `keyup 键被松开`     | `focus 获得焦点`                       | `scroll 滚动指定的元素 scrollTop()`                           |
| `mouseleave 鼠标离开` |                        | `blur 失去焦点`                        | `unload 方法在 jQuery 版本 1.8 中被废弃，在 3.0 版本被移除。` |
| `mousedown 鼠标按下`  |                        |                                          |                                                                 |
| `mouseup 鼠标松开`    |                        |                                          |                                                                 |
| `hover`               |                        |                                          |                                                                 |

| 显示、隐藏                  | 作用               |
| --------------------------- | ------------------ |
| `hide(slow) / hide(time)` | 隐藏               |
| `show`                    | 显示               |
| `toggle`                  | 切换hide()和show() |

| 淡入淡出 fade in out toggle        | 作用                                                                  |
| ---------------------------------- | --------------------------------------------------------------------- |
| `fadeIn(speed,callback)`         | 淡入已隐藏的元素                                                      |
| `fadeOut(speed,callback)`        | 淡出可见元素                                                          |
| `fadeToggle(speed,callback)`     | fadeIn() 与 fadeOut() 方法之间进行切换                                |
| `fadeTo(speed,opacity,callback)` | "slow"、"fast" 或毫秒，允许渐变为给定的不透明度（值介于 0 与 1 之间） |

| 滑动元素 slide down up toggle   | 作用                                      |
| ------------------------------- | ----------------------------------------- |
| `slideDown(speed,callback)`   | 向下滑动元素                              |
| `slideUp(speed,callback)`     | 向上滑动元素                              |
| `slideToggle(speed,callback)` | slideDown() 与 slideUp() 方法之间进行切换 |

| 动画                                | 作用                                                                                                                                                                                 |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `animate({params},speed,calback)` | 动画效果（可以操作多个属性，使用相对值，使用预定义的值，使用队列功能）第一个参数：键值对，（数值的属性可以改颜色不能改）``第二个参数：动画的时间``第三个参数：回调函数 |
| `stop(stopAll,goToEnd)`           | 停止动画                                                                                                                                                                             |

| 修改文本   | 作用                               |
| ---------- | ---------------------------------- |
| `text()` | 设置或返回所选元素的文本内容       |
| `html()` | 设置或返回所选元素的内容           |
| `val()`  | 设置或返回表单字段的值             |
| `attr()` | HTML 元素我们自己自定义的 DOM 属性 |
| `prop()` | HTML 元素本身就带有的固有属性      |

| 插入内容           | 作用                 |
| ------------------ | -------------------- |
| `append()`       | 结尾插入内容         |
| `prepend()`      | 元素开头插入内容     |
| `after()` 标签前 | 被选元素之后插入内容 |
| `before()`       | 被选元素之前插入内容 |

- append/prepend 是在选择元素内部嵌入。
- after/before 是在元素外面追加。

| 删除元素          | 作用                       |
| ----------------- | -------------------------- |
| `remove()` 删除 | 删除被选元素（及其子元素） |
| `empty()`       | 从被选元素中删除子元素     |

| 操作css                            | 作用                                |
| ---------------------------------- | ----------------------------------- |
| `addClass()`                     | 向被选元素添加一个或多个类          |
| `removeClass()`                  | 从被选元素删除一个或多个类          |
| `toggleClass()`                  | 对被选元素进行添加/删除类的切换操作 |
| `css({"":"","":""})，css("","")` | 设置或返回样式属性                  |

<img src="笔记/前端笔记/前端/必记API.assets/img_jquerydim.gif" alt="jQuery Dimensions" style="zoom:67%;" />

| 尺寸              | 作用                                                 |
| ----------------- | ---------------------------------------------------- |
| `width()`       | 设置或返回元素的宽度（不包括内边距、边框或外边距     |
| `height()`      | 设置或返回元素的高度（不包括内边距、边框或外边距     |
| `innerWidth()`  | 返回元素的宽度（包括内边距） +  padding              |
| `innerHeight()` | 返回元素的高度（包括内边距）                         |
| `outerWidth()`  | 返回元素的宽度（包括内边距和边框）+ padding + border |
| `outerHeight()` | 返回元素的宽度（包括内边距和边框）                   |

| 遍历               | 作用                                                                          |
| ------------------ | ----------------------------------------------------------------------------- |
| 向上遍历           | parent()                                                                      |
| `parent()`       | 方法返回被选元素的直接父元素                                                  |
| `parents()`      | 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 `(<html>)`       |
| `parentsUntil()` | 方法返回介于两个给定元素之间的所有祖先元素 ``$("span").parentsUntil("div");`` |
| 向下遍历           |                                                                               |
| `children()`     | 方法返回被选元素的所有直接子元素                                              |
| `find()`         | 方法返回被选元素的后代元素，一路向下直到最后一个后代。                        |
| 同胞               |                                                                               |
| `siblings()`     | 当前元素的所有兄弟元素                                                        |
| 之后               |                                                                               |
| `next()`         | 返回被选元素的下一个同胞元素                                                  |
| `nextAll()`      | 返回元素的所有跟随的同胞元素                                                  |
| `nextUnit()`     | 返回介于两个给定参数之间的所有跟随的同胞元素                                  |
| 之前               |                                                                               |
| `prev()`         | 返回前面的同胞元素                                                            |
| `prevAll()`      | 返回前面所有的同胞元素                                                        |
| `prevUntil()`    | 返回介于两个给定参数之间的所有跟随的同胞元素                                  |

| 过滤         | 作用                                                                         |
| ------------ | ---------------------------------------------------------------------------- |
| `first()`  | 首个元素                                                                     |
| `last()`   | 最后一个元素                                                                 |
| `eq()`     | 返回被选元素中带有指定索引号的元素                                           |
| `filter()` | 允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回 |
| `not()`    | 返回不匹配标准的所有元素。                                                   |

| 方法                        | 作用                            |
| --------------------------- | ------------------------------- |
| `end()`                   | 修复断链                        |
| `bind()\unbind()` 不推荐  | 同一个元素绑定多个事件 解绑事件 |
| `delegate()\undelegate()` | 绑定事件 解绑事件               |
| `on()\off()`              | 绑定事件 解绑事件               |
| `trigger()`               | 触发事件                        |

```js
$("#btn").bind({"click":function(){},"moverover“:function(){}});
$("#btn").bind("click moverover",function(){});
$("#dv").delegate("p",click,function(){	alert()})$("").on("click",function(){	$("").on("click","p",function(){	})})$().on("click",function(){	$("#btn1").off("click");	off参数是要解绑的事件的名字})$("txt").focus()$("txt").trigger("focus")$("txt").triggerHandler("focus")
```

事件对象

- event.delegateTarget 代码绑定的对象
- event.currentTarget 绑定事件的对象
- event.target 真正触发事件的对象
- e.stoPropagation()  取消默认事件
- event.preventDefault()  链式编程原理

| Ajax       | 作用                                                                                                                                      |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `load()` |                                                                                                                                           |
| `get()`  | 从服务器获得（取回）数据，从指定的资源请求数据                                                                                            |
| `post()` | 也可用于从服务器获取数据。不过，POST 方法不会缓存数据，并且常用于连同请求一起发送数据，向指定的资源提交要处理的数据，`向服务器提交数据` |

```js
// 解决问题 在当前 页面下发送 指定网站的请求 // 发起ajax请求 load$('#content > div:nth-child(14) > div').load('http://120.78.149.188:3000/search?keywords=%E6%B5%B7%E9%98%94%E5%A4%A9%E7%A9%BA')//  $.get(URL,callback);//  $.post(URL,data,callback);$.get("http://120.78.149.188:3000/search?keywords=%E6%B5%B7%E9%98%94%E5%A4%A9%E7%A9%BA",function(data,status){    console.log(data)})$.post("http://120.78.149.188:3000/search",{ keywords : "你的名字" },function(data,status){    console.log(data)    console.log(data)})
```

| 符号             | 作用                                 |
| ---------------- | ------------------------------------ |
| `noConflict()` | jQuery 使用 $ 符号作为 jQuery 的简写 |

| JSONP     | 作用                                                                                                      |
| --------- | --------------------------------------------------------------------------------------------------------- |
| `JSONP` | Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据 |

```js
// 需要服务器端配合
```

# es6

## 概念

- 2015.6 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准

let const var 块级作用域

- let 声明变量 代码块内有效
  - 不存在变量提升
  - 暂时性死区
  - 不允许重复使用
  - 增加块级作用域

- const 声明常量
- var 声明常量和变量
- 块级作用域

## 解构赋值 

变量 数组 对象  字符串 数值和布尔值 函数参数

- 数组
- 对象
- 字符串
- 数值
- 圆括号问题

## 扩展

### 字符串扩展

- 字符串扩展
  - Unicode表示法
  - 字符串的遍历器接口
  - JSON.stringify()
  - 模板字符串
  - 标签字符串
  - 模板字符串的限制
- 字符串新增方法
  - String.fromCodePoint()
  - String.raw()
  - 实例方法
    - codePointAt()
    - normalize()
    - include()、startsWith()、endsWith()
    - repeat()
    - padStart()、padEnd()
    - trimStart()、trimEnd()
    - matchAll()

### 正则的扩展

- RegExp 构造函数
- Unicode属性类
- 具名组匹配
- 正则匹配索引
- String.prototype.matchAll()
- 字符串的正则方法
- u修饰符
- y修饰符
- s修饰符：dotAll模式
- RegExp.prototype.unicode
- RegExp.prototype.sticky
- RegExp.prototype.flags

### 数值的扩展

- 二进制和八进制表示法
- 数值分隔符
- Number
  - Number.isFinite()，Number.isNaN()
  - Number.parseInt()，Number.pareFloat()
  - Number.isInteger()
  - Number.EPSILON
  - 安全整数和Number.isSafeInteger()
- Math
  - trunc sign cbrt clz32 imul fround hypot
- BigInt数据类型

### 函数的扩展



### 数组的扩展

- Array.from()
- Array.of()
- 实例方法
  - copyWithin()
  - find() findIndex() findLast() findLastIndex
  - fill()
  - entries() keys() values()
  - includes()
  - flat() flatMap()
  - at()
  - toRevesed() toSorted() toSpliced() with()
  - group() groupToMap()
  - 数组的空位
  - Aarray.prototype.sort（）的排序

### 对象的扩展



### 运算符扩展

- 指针运算符 `**`: 乘方 先右算 `**=  b**=4 ==> b=b*b*b*b=b^4`
- 链判断运算符`?.` *链式调用的时候判断，左侧的对象是否为*`null`*或*`undefined`*。如果是的，就不再往下运算，而是返回*`undefined`
- Null判断运算符 `??`。它的行为类似`||`，但是只有运算符左侧的值为`null`或`undefined`时，才会返回右侧的值
- 逻辑赋值运算符 这三个运算符`||=`、`&&=`、`??=`相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。为变量设置默认值

## Symbol 

解决：方法名冲突，新增symbol保证每个属性名独一无二，从根本防止属性名冲突

Symbol `独一无二的值`  新增的数据类型

- symbol.prototype.description 创建Symbol时，可以添加一个描述
- 内置的Symbol值
  - Symbol.hasInstance
  - Symbol.isConcatSpreadable
  - 

## Set和Map数据结构

Set

WeakSet



## Proxy

## Reflect

## Promise

含义
基本用法
Promise.prototype.then()
Promise.prototype.catch()
Promise.prototype.finally()
Promise.all()
Promise.race()
Promise.allSettled()
Promise.any()
Promise.resolve()
Promise.reject()
Promise.try()

## Iterator 和 for … of 循环



## Generator

一种异步阶级方案

传统方法

基本概念

Generator函数

Thunk 函数

co模块

## async

## class

## module

## 异步遍历器

## ArrayBuffer

## 函数式编程

# typescript

# vue

vue数据双向绑定原理；
vue computed原理、computed和watch的区别；
vue编译器结构图、生命周期、vue组件通信；
mvvm模式、mvc模式理解；
vue dom diff、vuex、vue-router

mvc（后端） mvp mvvm（前端）

- m 模型 数据 v 视图  【p 逻辑处理  c控制器 负责逻辑 vm 视图模型
- m->v->c->m 单向圆  m<=>p<=>v   v

vue composition

option api => composition（组成） api

解决的问题：将各种类型的代码分类写在对应的地方不比把所有的代码都写在一个setup函数中

- vue2 optioin api 相同的逻辑写在不同的地方、逻辑交叉错乱
  - components:{} data(){} watch:{} mounted():{}
- vue3 compostion api  兼容vue2 相同逻辑写在同一个地方、使用函数抽离处来，方便代码阅读
  - 增加 setup(props context){} 选项 负责逻辑
  - data、computed可以使用
  - reactive、computed、watch、onMounted等抽离的接口代替vue2中data

逻辑抽取与复用

- vue2 mixin Scoped slot

  - mixin
  - scoped slot 使用组件抽取逻辑，然后通过作用域插槽暴露给子组件
    - 增加缩进，可读性差
    - 增加配置，不灵活。需要在slot上增加配置，以应对更多的情况
    - 能差。仅为了抽取逻辑，需要创建维护一个组件实例。
- vue3 composition function 像函数抽离逻辑

  - 把逻辑处理成函数

# node

进程 process是计算机中的程序关于某数据集合中的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是 ``资源分配的最小单位``。我们启动一个服务、运行一个实例，就是开一个服务进程。

```js
const http = require('http')
const server = http.createServer();

server.listen(300,()={
    console.log('创建一个进程')
})
```

线程

线程是操作系统能够进行 ``运算调度的最小单位``，首先我们要清楚线程是隶属于进程的，被包含于进程之中。**一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的**。

- 单线程：**单线程就是一个进程只开一个线程**
- 多线程

```js
const http = require('http');
const longComputation = () => {
  let sum = 0;
  for (let i = 0; i < 1e10; i++) {
    sum += i;
  };
  return sum;
};
const server = http.createServer();
server.on('request', (req, res) => {
  if (req.url === '/compute') {
    console.info('计算开始',new Date());
    const sum = longComputation();
    console.info('计算结束',new Date());
    return res.end(`Sum is ${sum}`);
  } else {
    res.end('Ok')
  }
});

server.listen(3000);
//打印结果
//计算开始 2019-07-28T07:08:49.849Z
//计算结束 2019-07-28T07:09:04.522Z
```

nodejs 是javascruot在服务端的运行环境，构建在Chrome的V8 引擎之上。是单线程模式、基于事件驱动、异步非阻塞模式、可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。充分利用操作系统提供的异步 I/O 进行多任务的执行，适合于 I/O 密集型的应用场景，因为异步，程序无需阻塞等待结果返回，而是基于回调通知的机制，原本同步模式等待的时间，则可以用来处理其它任务，

- 事件驱动 结构是一种建立砸软件开发中一种通用模式之上，这种模式被称为发布-订阅或观察者模式，两个参与者：**主题（subject）\**和\**观察者（observer）**。个实体广播一条消息，其他实体侦听该消息。
- 异步非阻塞模式
  - IO 概念
    - 同步（Synchronous）
    - 异步( Asynchronous)
    - 阻塞( Blocking )
    - 非阻塞( Nonblocking)

# nginx

# webpack

- 安装 webpack webpack-cli
- webpack命令： webpack .\src\main.js -o .\dest\bundle.js
- 配置文件： webpack.config.js  package.json
- 两个环境： 生产环境 与 开发环境
- 四大核心概念 Entry Output Loader Plugins

```js
webpack.config.js

const path = require('path')
// 在配置文件中，需要手动指定入口和出口 exports出口
console.log(path)
module.exports = {
    //	入口，表示，要使用webpack打包那个文件
    entry: path.join(__dirname, './src/main.js'),
    output: { // 输出文件相关的配置
        path: path.join(__dirname, './dist'),//指定打包好的文件，输出到哪个目录中去
        filename: 'bundle.js' //输出的文件的名称
    }
}
```

- package.json

```
script:{
	"dev":"webpack --mode development",
	"build":"webpack --mode production "
}
```

- plugin

  - webpack-dev-serve 自动运行项目 -D
    - npm install webpack-dev-server@2.9.7 -D
    - webpack-dev-server的版本太高的锅，3.以上的还是不行。所以降到2.11.3一下左右即可

  ```
  "dev":"webpack-dev-server --open --port 3000 --contentBase src --hot"devServer:{ // 配置dev-server命令参数的第二次形式，相对来说，这种方式麻烦一些    open:true, //自动打开浏览器    port:3000,// 设置启动时候的运行端口    contentBase: 'src'//指定托管的根目录 src 要带 ‘’ 号    hot:true // 启用热更新 }plugins:[ //数组    new webpack.HotModuleReplacementPlugin();    //new 一个热更新的模块对象 这是启动更新]
  ```

  - html-webpack-plugin   npm i html-webpack-plugin -D

  ```js
  const webpack = require('webpack')const htmlWebpackPlugin = require('html-webpack-plugin')plugins:[     new webpack.HotModuleReplacementPlugin(),//创建一个在内存中，生成HTML页面的插件   new htmlWebpackPlugin({  	template:path.join(_dirname,'./src/index.html'),   	//指定模板页面，会根据指定的页面路径，去生成内存中的页面   	filename:'index123.html' //指定生成的页面的名称    })]
  ```
- loader

  - css
    - npm i style-loader css-loader -D   `css`
    - npm i less-loader less -D `less`
    - npm i sass-loader node-sass -D `scss`
  - image 字体
    - npm i url-loader file-loader -D
  - babel

  ```
  //第一套包 babel转换工具npm i babel-core babel-loader babel-plugin-transform-runtime -Dbabel-core/loader plugin-transform-runtime //第二套包 语法插件npm i babel-preset-env babel-preset-stage-0 -Dbabel-preset- env/stage-0
  ```

  ```js
  module:{
  	rules:[
  		{test:/\.css&/,use:['style-loader','css-loader']},
  		{test:/\.less&/,use:['style-loader','css-loader','less-loader']},
          {test:/\.scss$/,use:['style-loader','css-loader','sass-loader']},
          {test:/\.(ttf|eot|svg|woff|woff2)$/,use:'url-loader'},
          {test:/\.(jpg|png|gif|bmp|jpeg)$/,use:'url-loader?limit=7631$name=[name].[ext]'}
          { test:/\.js$/,use:'babel-loader',exclude:/node_modules/ }
  	]
  }
  
  // presets  语法
  .babelrc文件
  {
  	"presets":["env","stage-0"], //语法
  	"plugins":["transform-runtime"] //插件
  }
  ```

# 数据结构与算法

# 软件工程

# 计算机网络

HTTP1, HTTP2, HTTPS、常见的http状态码；
浏览从输入网址到回车发生了什么；
前端安全（CSRF、XSS）
前端跨域、浏览器缓存、cookie, session, token, localstorage, sessionstorage；
TCP连接(三次握手, 四次挥手)
性能相关

图片优化的方式
500 张图片，如何实现预加载优化
懒加载具体实现
减少http请求的方式
webpack如何配置大型项目

# 设计模式

# 响应式设计和自适应设计

# H5移动端网页

# PC网页

### 网页布局常见规范

# 微信小程序

# 微信公众号

# 微信小游戏

# 单元测试

[前端单元测试技术方案总结](https://juejin.cn/post/6935246645323890724)

[从零开始写单元测试](https://juejin.cn/post/6856754311867826190)

[前端单元测试那些事](https://juejin.cn/post/6844904051449036808#heading-5)

## 通用测试

## chai

## mocha和Jasmin

## jest
